{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CEG5203 Assignment Manuals","text":"<p>Welcome to the exciting world of hardware acceleration. We have prepared a series of labs for this course to give you hands-on experience in Hardware/Software Co-design. Each lab consists of two parts: 1) the first part consists of a tutorial with step-by-step guidance and 2) the second part is an assignment to allow students to use practical knowledge gained from the first part to solve a fairly simple design and implementation problem.</p>"},{"location":"#board","title":"Board","text":""},{"location":"#board-collection-venue","title":"Board Collection Venue","text":"<p>Digital Electronics Lab (E4 level 3). Only 9 am to 12 noon, and 2 pm to 5 pm on working days.</p>"},{"location":"#kria-board","title":"Kria Board","text":"<p>You will be provided a Kria KV260 SOM Vision Starter Kit containing an AMD/Xilinx Zynq Ultrascale+ SoC. More information about the board can be found at https://www.amd.com/en/products/system-on-modules/kria/k26/kv260-vision-starter-kit.html (scroll down).</p>"},{"location":"#board-handling-guidelines","title":"Board Handling Guidelines","text":"<p>Like most development boards and PCBs, your FPGA board is fragile. Treat it with care and respect, as if it were your own. It is reasonably expensive at over S$500, and not so easy to get replaced.</p> <p>Here are some tips to take good care of your board:</p> <ul> <li>Do not touch the PCB tracks, or the components on the board. Static discharge can damage or destroy electronic components, and these boards can be particularly susceptible.</li> <li>Use the nice plastic box with foam lining to transport your FPGA board. Do not use a plastic bag or other plastic container to carry your boards, and most certainly don't put it bare in your backpack/tote/briefcase/whatever you bring to class.</li> <li>When using the board, keep it on a stable, flat surface. Do NOT have it hanging off the USB cable, or hanging off the edge of a table, or on your lap, or anywhere that isn't a suitable, solid surface.</li> <li>Absolutely DO NOT DROP your board. When moving it around, hold the board by the edges and make sure the USB cable is unplugged so as to minimize strain on the port and to avoid it getting caught on something.</li> <li>Avoid plugging and unplugging the micro-USB cable more than necessary. To reset the board, you can use the power switch on the top left of the board, or unplug the USB-A connector from your computer if really necessary. Micro USB is a notoriously fragile connector, and it's best to avoid putting more strain on it than necessary. USB-A is much sturdier so that end of the cable is not as much of a concern.</li> <li>Apply common sense and standard practices for taking care of electronics: don't eat or drink near your board in case you get crumbs (or worse, a spill) on the board. Don't throw the board around. Plug and unplug accessories with care. Be gentle when using the switches and buttons.</li> </ul>"},{"location":"#policies","title":"Policies","text":""},{"location":"#late-demosubmission-policy","title":"Late demo/submission policy","text":"<p>You are supposed to submit your assignment to Canvas by the deadline for uploading - if you submit after the deadline, you will be given a high penalty. You are expected to submit the exact same code to assignments and demonstrate to the teaching assistant - any bug fixes/improvements after the deadline could you useful for future labs and project, but will not result in an increase in marks after the submission.</p> <p>A late demo is allowed (with no penalty)\u00a0only if you can produce documented evidence to explain the late demo/submission - in such a case, please let us know as soon as you can.</p>"},{"location":"#email-policy","title":"Email policy","text":"<p>Kindly\u00a0DO NOT send emails regarding labs wherever possible. See below on how to get help. Only if the matter is personal/administrative, please contact the lecturer via Canvas Inbox (not emails).</p>"},{"location":"#how-to-get-help","title":"How to get help","text":"<p>If you have any questions regarding the content of any of the assignments, please follow these steps, in this order, to answer them.  </p> <ol> <li> <p>Please read the assignment manual closely. We will try our best to keep the manual updated with any common errors or issues that you may face.</p> </li> <li> <p>If the assignment manual does not answer your question, the GitHub repository has a discussions page. Please search here for your question, in case it has already been answered before. We will leave questions and answers from previous semesters on this page, so over time, more and more information should be covered between here and the manuals.</p> </li> <li> <p>If you cannot find an answer to your question in the discussions either, then please create a new discussion. Make sure your title is as succinct, but descriptive, as possible, for the benefit of others who may search the issues page later. Also, do make sure you include all relevant details in the discussion content. This webpage offers some helpful advice on how to ask good technical questions.</p> </li> <li> <p>Please DO NOT send emails to the teaching staff asking technical questions regarding the lab activities. We will ignore all such emails, with no exception. Post all technical questions to the discussions page. This benefits others because anyone who has the issue in the future can solve it quickly with a search. It also benefits you, because you may receive an answer faster from a classmate, than from us.</p> </li> </ol> <p>On that subject, please do join in and help each other out in the discussions as far as possible.</p>"},{"location":"#plagiarism-warning","title":"Plagiarism Warning","text":"<p>It might be tempting to 'refer' to the code found in the textbook / online sources. However, please note that we take dishonesty very very seriously. If we are confident that you did plagiarize, you might not even be given a chance to explain. Consequences can range from an unpleasant surprise on the day of the release of results to having an interview with the NUS board of discipline.</p> <p>If you think renaming variables / rearranging code helps circumvent plagiarism detection, you might want to read this -\u00a0http://en.wikipedia.org/wiki/Plagiarism_detection#In_source_code.</p> <p>Discussions are encouraged, but 'we had discussed' is not a valid excuse if your codes turn out to be uncomfortably similar.</p> <p>Though there will be intra-team differentiation in marks according to the contribution levels, a team will be collectively responsible for plagiarised code. Your teammates might be better off with no contribution at all from you than to receive plagiarised code.</p>"},{"location":"#updates","title":"Updates","text":""},{"location":"#license","title":"License","text":"<p>NUS CEG5203 Assignment Manuals \u00a9 2025 by NUS CEG5203 Team is licensed under CC BY-NC-SA 4.0 </p>"},{"location":"Assignment_1/1_Intro/","title":"Introduction to Hardware/Software Co-Design","text":"<p>Final</p> <p>This assignment description is now complete. There could still be minor updates, which will be highlighted. </p>"},{"location":"Assignment_1/1_Intro/#introduction","title":"Introduction","text":"<p>This manual contains step-by-step instructions on how to create a hardware platform that utilizes the ARM Cortex A53 processor in the Kria board (there are four of them; we will be using only one through) and to execute simple C programs on it. The following 4 pages have the details you will need in the process.</p> <p>Creating the hardware platform - This page describes how to use Vivado to create a hardware platform using IP Integrator, and to synthesize the hardware into a bitstream. The bitstream is used to configure the FPGA to become the hardware platform that we have created. The bitstream and other hardware info are exported as a .xsa file.</p> <p>Software development using Vitis - This page describes how to use Vitis IDE to create a C program to run on the Cortex A53 processor and interacting with the peripherals we have integrated in the step above. If you are using Vitis version &lt;= 2023.2, please follow the instructions for Software development using Vitis Classic instead.</p> <p>Serial Console - RealTerm - This page describes how to use RealTerm, the recommended console program (you are free to use other serial terminal programs or even have your own program for the purpose, e.g., a custom Python code using PySerial library) to send and receive information to the program running on the Cortex A53 processor through UART.</p> <p>Performance analysis - This page describes some general approaches to performance analysis, as well as the specific approach followed in the assignment, which is using an AXI Timer peripheral.</p>"},{"location":"Assignment_1/1_Intro/#assignment-1","title":"Assignment 1","text":"<p>Assignment #1 is a homework exercise and carries\u00a010\u00a0marks.</p> <p>The template/data files are here.</p> <p>The matrix A is a 64 x 8 matrix given in A.csv (CSV = comma-separated values). The elements of A are in the corresponding ASCII form in A.csv - this is essentially a text file and can be opened using a text editor*. You can also open it with Excel, which will show it as a table. </p> <p>The matrix B is an 8 x 1 matrix given in B.csv, encoded in a similar manner as A.csv. </p> <p>These two files should be sent from RealTerm (or another terminal program) to your C program running on board. Your C program should </p> <ul> <li>receive matrices A and B into a local array/arrays (either a single array for A and B together or separate arrays);</li> <li>pass it through the AXI Stream FIFO configured in loopback mode - no processing done in hardware/PL, for now;</li> <li>compute the result matrix, RES =\u00a0A*B/256;</li> <li>send RES back from the board to the PC (RealTerm).</li> </ul> <p>The received result should be captured into a file via RealTerm. The name of the file has to be \u201cRES.csv\u201d.\u00a0You can compare the RES.csv with Labels.csv on your PC using an Excel-like program (i.e., Labels.csv should not be sent to the board). Do you observe any pattern?</p> <p>Further, you should integrate an AXI Timer into your block design, and modify your software C code to report</p> <ul> <li>the time taken for sending all the input data matrices A and B through the AXI Stream FIFO, and</li> <li>the time taken for matrix multiplication (A*B/256).</li> </ul> <p>The relative time required for the above two has to be reported through profiling as well. Some hints on how this can be done is given on the Performance analysis page.</p> <p>You should do all computations in C on the board using integers. Do not use floating-point (i.e., variables should not be declared as float).</p>"},{"location":"Assignment_1/1_Intro/#submission-info","title":"Submission Info","text":"<p>Assignment 1 (10 marks)</p> <p>Upload the (only those files you have created/modified, not the entire project folder)</p> <ul> <li>.xsa file</li> <li>.c/.h files</li> <li>input/output test files</li> <li>a text file that mentions the time taken in cycles or milliseconds (you should be able to convert between the two easily anyway) - this info can be copy-pasted from the realterm console to a text file</li> <li>a screenshot of the profiling output to Canvas by 11:59 PM, 15 Sep 2025. The deadline is slightly negotiable for part-time students. You will also be required to do a demonstration (based on what you submitted at the point of the assignment deadline, not the version you may have improved after the deadline) to a teaching assistant sometime in the future - details to be announced.</li> </ul> <p>It should be as a single .zip archive, with the filename &lt;Team number&gt;_&lt;Team member 1 Name&gt;_&lt;Team member 2 Name&gt;_1.zip</p> <p>Please DO NOT upload the whole project!</p>"},{"location":"Assignment_1/1_Intro/#dataset-description-optional-read","title":"Dataset Description (Optional Read)","text":"<p>Here, we use a modified version of the Wine dataset from\u00a0https://archive.ics.uci.edu/ml/datasets/wine. You can read up the description and more if you are interested.</p> <ul> <li>The original 3-class problem is reduced to a 2-class problem by removing the cases with label 3.</li> <li>Some features are also removed, to reduce the feature dimensionality from 13 to 8.</li> <li>The original features are normalized to be between\u00a0[0, 1), represented using the 0.8-bit fixed point representation we had used in Lab 1.</li> <li>You can visualize the data using some easy-to-use programming language such as Python or Matlab (https://octave-online.net/ is pretty cool), or even Excel.</li> <li>What we do in this lab is essentially the prediction/inference step in machine learning/classification. The classifier is trained using Fisher's linear discriminant\u00a0method (matrix B\u00a0in the description above is the weight vector), with some modifications to accommodate the 8-bit format.</li> </ul>"},{"location":"Assignment_1/2_HW_Platform/","title":"Creating the Hardware Platform","text":"<p>This page describes how to use Vivado to create a hardware platform using IP Integrator, and to synthesize the hardware into a bitstream. The bitstream is used to configure the FPGA to become the hardware platform that we have created. The bitstream and other hardware info are exported as a .xsa file.</p> <p>Note: There are slight differences in GUI and options based on the version. The spirit of what is being done remains the same.</p> <p>Open Vivado.</p> <p>File&gt;Project&gt;New</p> <p>Info</p> <p>As a general rule, DO NOT use spaces in the paths for any of your projects/workspaces. This is a good practice not only for Vitis/Vivado but for a number of hardware and software development tools.</p> <p>Next&gt; Specify a project name and location&gt;Next&gt;Next&gt;Next&gt;Next&gt; Select the board - go to the boards tab and select\u00a0Kria KV260 Vision AI Starter Kit SOM &gt;Next&gt;Finish.</p> <p></p> <p>Vivado Project manager will now open up.</p> <p>Under IP Integrator, click Create Block Design.</p> <p></p> <p>Accept the default name and options, and click OK.</p> <p>In the IP Integrator canvas that opens up, click the Add IP button .</p> <p>Search for and add Zynq UltraScale+ MPSoC</p> <p></p> <p>Click on Run Block Automation. This will apply some preset settings for the chip/board. We will be changing this substantially later though.</p> <p></p> <p>Accept the defaults and press ok.</p> <p>Now double-click on the Zynq Ultrascale+ block. You can now see the ultrascale+ block diagram. Have a good look.</p> <p>No, under I/O configuration, enable UART and you can safely disable everything else. Here, we are configuring the multiplexed IOs, and\u00a0MIO pins 36 is TX, 37 is RX. We need only those for now.</p> <p></p> <p>In the Clock configuration, you can uncheck PL1. PS generates clock(s) for PL. We can have multiple clocks with the same or different frequencies. We need only one 100 MHz clock for PL, at least for now.</p> <p></p> <p>In the PS-PL configuration, we can choose AXI HPM0 FPD and uncheck AXI HPM1 FPD. Using AXI HPM0 LPD is also ok (FPD = full power domain. LPD = low power domain). This is the master AXI interface, to which the slaves created in PL will be connected. Select the data width as 32.</p> <p></p> <p>You should now see the block below. Click and drag from pl_clk0 to make a connection to maxihpm0_fpg_aclk.</p> <p></p> <p></p> <p>At any point, if you want to beautify the layout, you can click </p> <p>The validate your design, i.e., to check if there are incompatible connections / essential connections that are not made, click . If no error or critical warning, we have completed the basic block design.</p> <p>While this is good enough to do the basic requirements for this lab, let us push ourselves a bit more and get readier for future labs.</p> <p>Click the + button on the IP Integrator canvas to add an IP. Select AXI-Stream FIFO. . This IP acts as a bridge between AXI (the bus-based, addressable bus system) to AXI-Stream (point-to-point, non-addressable link). This will be used to integrate our coprocessor into the rest of the system in future labs so that the main processor can send/receive data via AXI.\u00a0</p> <p>While the IP Integrator shows the option for running connection automation, do not do this as yet. Instead, double-click on the AXI Stream FIFO that we added to customize it.</p> <p>Change the settings as follows, and click OK. Choosing AXI (full AXI) instead of AXI Lite (default) allows the data transfer to be potentially faster, as full AXI can do burst transfers (slave auto-increments addresses so that multiple data can be transferred with a single address). We can disable 'Enable Transmit Control' as we will be doing all the data transfer continuously. Make sure that the Data Width is 32. </p> <p>Under the Transmit FIFO options AND the Receive FIFO options (not shown in picture), increase FIFO depth to 1024, as we will be sending more than 512 words later through the loopback connection between the TX and RX line which passes through both buffers.</p> <p></p> <p>Now, click on </p> <p>Select both the automations and click OK.\u00a0</p> <p></p> <p>It will add two blocks - Processor System Reset (to reset peripherals as appropriate - more useful in designs using Microblaze, a soft processor), and an AXI Interconnect - since AXI Stream FIFO has 2 slave interfaces, both of which need to be connected to the same master interface of PS.</p> <p>Finally, make a loopback connection - connect the AXI_STR_TXD to AXI_STR_RXD. Since we do not have a co-processor yet, this connection will have the effect of a coprocessor that simply echos (sends back) the data it receives.</p> <p></p> <p>You can now optionally click on Regenerate Layout button (the clock-wise symbol) to tidy up the diagram. It should look like below.</p> <p></p> <p>It is also a good time to inspect (no action required) the address editor tab. This shows the addresses of the memory-mapped peripherals / interfaces. We have two corresponding to AXI (mentioned as S_AXI_FULL) and AXI Lite (S_AXI) interfaces of the AXI Stream FIFO. You can edit the addresses and ranges if you wish, but unless you have a good reason to (or if you are into numerology), it is fine to leave it as such.</p> <p></p> <p>We are done with the block design. Save the block design (Ctrl+S).</p> <p>Synthesis tools can't synthesize a block design directly. We need to convert the block design into HDL. Under Sources &gt; Design Sources, right-click the .bd file and select 'Create HDL Wrapper'.\u00a0</p> <p></p> <p>Accept the default, i.e., let 'Vivado manage ...' and click OK.</p> <p>Now click 'Generate Bitstream' and OK.</p> <p>Once it is done, File &gt; Export &gt; Export Hardware &gt; Next &gt; Change to Include Bitstream.</p> <p>Next &gt; (note the path, the default is the project directory itself)&gt; Next &gt; Finish.</p> <p>For the various steps such as synthesis/implementation etc,\u00a0 setting the number of jobs equal to the number of cores (maximum in the drop-down list) may cause it to complete faster, esp on Linux. Often, the number appearing by default is 4, which can be changed to a higher number. If you have other programs running in the background, set it to the maximum value in the list minus one or two.</p> <p>Continue to the instructions for software development using Vitis.</p>"},{"location":"Assignment_1/3_Using_Vitis/","title":"Software development using Vitis","text":"<p>If you are using Vitis version &lt;= 2023.2, please follow the instructions for Eclipse-based Vitis Classic instead.</p> <p>This page details the steps involved in creating a software application using Vitis, an VS Code-based IDE, to run on the hardware platform created using Vivado. You should be using a Vitis version that matches your Vivado version.</p> <p>Note: There are slight differences in GUI and options based on the version. The spirit of what is being done remains the same.</p>"},{"location":"Assignment_1/3_Using_Vitis/#vitis","title":"Vitis","text":"<p>Open the Vitis IDE from the start menu or by clicking the desktop icon or from Tools &gt; Launch Vitis IDE from Vivado.</p> <p>Set a workspace. File&gt; Set Workplace. This can be any folder, though it might a good idea to create it under \\workspace, so that the hardware and software projects are in the same folder. <p>Create a new platform project. File &gt; New Component &gt; Platform.</p> <p>Note: It is also possible to start from File &gt; New Component &gt; Platform, which will prompt you to select/create a Platform Project. You can also choose create Application components later, to create applications such as a simple Hello World application.</p> <p>You will get a new platform project dialog. Enter a name for your project and location (or just accept the defaults), and click Next.</p> <p>In the next screen, make sure Hardware Design is selected. The click the Browse button. A file selector window will open, where you will have to navigate to\u00a0 and select the design_1_wrapper.xsa file and click Next.\u00a0\u00a0It will take a few seconds to read the .xsa file. Accept the defaults*.  <p>*OS=standalone, Processor=psu_cortexa53_0, Generate boot components (First Stage Boot Loader aka FSBL) checked, etc. It is possible to do a non-FSBL initialisation via .tcl scripts that invoke the debugger, but we will just let it be via FSBL. If you fancy playing with FreeRTOS (which gives you support for multithreading etc.), you can choose that, though for CEG5203, standalone (a library providing basic functions such as stdin/stdout used by prinft/scanf and some other basic functionalities for 'bare metal' programming) is good enough.</p> <p>Click Next and click Finish.</p> <p>You will now be presented with the workspace. Under the platform project, click on platform.spr. Click on Board Support Package under standalone on psu_cortexa53_0. You can now modify BSP settings if need be (though defaults should be fine), such as including various libraries, selecting the drivers to be used for various peripherals, selecting the std_in and std_out peripherals (which should both be psu_uart1), etc.</p> <p>You can import examples for the various peripherals. For a start, we can run an example program for psu_uart1, which is the peripheral we will be using for basic input/output (and will interact with the serial terminal/console program, e.g., RealTerm).</p> <p></p> <p>In the next screen, select xuartps_hello_world_example. You will now see the application project in the workspace.</p> <p>Have a look at the main source file, and understand the code.</p> <p>Now, click build to build the application.</p> <p></p> <p>It will prompt you with a dialog box. Select Always build platform with application radio button and Save in workspace preference button.</p> <p>Wait for the build to be completed.</p> <p>Make sure that you connect the micro USB cable to your computer and the board. Make sure that the board is powered on via the adaptor (it is not powered via USB). RealTerm (or another serial terminal program) should be opened and the correct port number should be selected (the lowest numbered among the multiple COM/ttys detected corresponding to the board).</p> <p>We can run the program by clicking Run as shown below (Debug is also ok, if we want debug controls such as single stepping). If you are getting errors (likely during a second run), try running again.</p> <p>.</p> <p>Info</p> <p>If your program is inhibiting unpredictable behavior when dealing with large data, it could be due to stack or heap size limitations. You can increase the heap or stack size by editing the linker script (.ld file) which you can find in the project sources.</p> <p>For future runs, if your hardware configurations has not been changed, you can uncheck the 'Reset Entire System' and 'Program Device' which may save some time.</p> <p>If the program ran successfully, you can see something similar to the screenshot below in your serial terminal (console) program such as RealTerm. The formatting could appear a bit different depending on the terminal program and CR/LF settings.</p> <p>.</p> <p>You can also click Debug, and then the standard VS Code debugging options become available. The screenshot shows the program suspended at the beginning. You can set single step, set breakpoints (double click to the left of the line number), run until breakpoint, step into functions, etc. It is a good idea to stop using the red stop button before starting a fresh Run/Debug.</p> <p>.</p> <p>If you are getting errors such as \"Could not find ARM device...\", the board is likely not detected - either the board is not powered on, or the cable is not connected, driver is not installed, or you did not allow some firewall warning during installation or first run. Try programming the FPGA using the Hardware Manager in Vivado (below the 'Generate Bitstream' option in the left menu).</p>"},{"location":"Assignment_1/3_Using_Vitis/#beyond-hello-world-running-axi-stream-fifo-example-program","title":"Beyond Hello World : Running AXI Stream FIFO Example program","text":"<p>Go to Board Support Package &gt; Standalone &gt; drivers (similar to how you did for UART), and select the example for axi_fifo_mm_s_0 as sho. This assumes a loopback connection in the block diagram / design we created in Vivado.</p> <p>Build, Run and see the results, which should show a success message in the serial terminal.</p>"},{"location":"Assignment_1/3_Using_Vitis/#optional-exercise","title":"Optional Exercise","text":"<p>Simple input/output : Write a simple program in Vitis to read a character from the console and print that character to the console (echo).</p> <p>Essentially, you sent out a character from RealTerm console to PSU_UART1 on the Kria board. The C program running on ARM Cortex A53 reads it from the PSU_UART1 input buffer (using scanf or UART driver functions), and writes it to the PSU_UART1 output buffer (using printf or UART driver functions). The PSU_UART1 will send it over to the RealTerm console, which will then display it.</p>"},{"location":"Assignment_1/3_Using_Vitis_Classic/","title":"Software development using Vitis Classic","text":"<p>If you are using Vitis version &gt;= 2024.1, please follow the instructions for VS Code-based Vitis (non-classic) instead.</p> <p>This page details the steps involved in creating a software application using Vitis, an Eclipse-based IDE, to run on the hardware platform created using Vivado. You should be using a Vitis version that matches your Vivado version.</p> <p>Note: There are slight differences in GUI and options based on the version. The spirit of what is being done remains the same.</p>"},{"location":"Assignment_1/3_Using_Vitis_Classic/#vitis-classic","title":"Vitis Classic","text":"<p>Open the VItis IDE from the start menu or by clicking the desktop icon. Do NOT start from Tools &gt; Launch Vitis IDE from Vivado, as it will launch VS Code based IDE, which we won't be using for now.</p> <p>Give a workspace path. This can be any folder, though it might a good idea to create it under \\workspace, so that the hardware and software projects are in the same folder.\u00a0 <p>This will bring up the IDE. Click Create Platform Project (or File&gt;New&gt;Platform Project).</p> <p>Note: It is also possible to start from Create Application Project, which will prompt you to select/create a Platform Project. You can also choose Create Application Project later, to create applications such as a simple Hello World application.</p> <p>You will get a new platform project dialog. Enter a name for your project, and click Next.</p> <p>In the next screen, click on the Create a new platfo.... (XSA) tab. The click the Browse button. A file selector window will open, where you will have to navigate to\u00a0 and select the design_1_wrapper.xsa file.\u00a0\u00a0It will take a few seconds to read the .xsa file. Accept the defaults*. While making sure that the correct .xsa is selected, click Finish. <p></p> <p>*OS=standalone, Processor=psu_cortexa53_0, Generate boot components (First Stage Boot Loader aka FSBL) checked, etc. If you fancy playing with FreeRTOS (which gives you support for multithreading etc.), you can choose that, though for EE4218, standalone (a library providing basic functions such as stdin/stdout used by prinft/scanf and some other basic functionalities for 'bare metal' programming) is good enough. You can uncheck the Generate boot components option - this will, however, cause an error to be flagged every time you build anything. While this shouldn't affect our functionality, if this can be annoying to you, you can leave it checked. The run configuration (later) is slightly different based on whether you leave it checked or uncheck it. Also, the non-FSBL initialization is generally more prone to random issues such as the debugger hanging.</p> <p>You will now be presented with the workspace. Under the platform project, click on platform.spr. Click on Board Support Package under standalone on psu_cortexa53_0. You can now modify BSP settings if need be (though defaults should be fine), such as including various libraries, selecting the drivers to be used for various peripherals, selecting the std_in and std_out peripherals (which should both be psu_uart1), etc.</p> <p>You can import examples for the various peripherals. For a start, we can run an example program for psu_uart1, which is the peripheral we will be using for basic input/output (and will interact with the serial console program, e.g., RealTerm).</p> <p></p> <p>In the next screen, select xuartps_hello_world_example. You will now see the application project in the workspace.</p> <p></p> <p>Have a look at the main source file, and understand the code.</p> <p>Now, click build to build the application. If need be, build the platform project (select the platform project and click build) before building the application.</p> <p></p> <p>Once the build has been completed, we can run the program. For this, we need to create a Run Configuration.\u00a0\u00a0</p> <p>Click the drop-down button next to Run, and click Run Configurations.</p> <p></p> <p>Double click Single Application Debug, and you will see a Debugger_xuartps_hello_... under it. \u00a0In the Application tab (next to the Main tab), make sure that the\u00a0Project, as well as Application fields, are populated. If not, click Browse and select the Project; click Search and select the .elf file.</p> <p></p> <p>Configure Target Setup as follows, depending on whether you checked 'Generate Boot Components' (aka FSBL) in an earlier step or not.</p> <p>Using FSBL -</p> <p></p> <p>Not using FSBL - more prone to debugger hanging. This can be used even when FSBL is included in the platform project.</p> <p></p> <p>Make sure that you connect the micro USB cable to your computer and the board. Make sure that the board is powered on via the adaptor (it is not powered via USB). RealTerm should be opened and the correct port number should be selected (the lowest numbered among the multiple COM/ttys detected corresponding to the board).</p> <p>Once that is done, you can click\u00a0Apply and then Run. If an Overwrite Boot Mode warning appears, click Yes.</p> <p>If you are getting errors such as \"Could not find ARM device...\", the board is likely not detected - either the board is not powered on, or the cable is not connected, driver is not installed, or you did not allow some firewall warning during installation or first run. Check if you can program the FPGA (not run the program) by going to Vitis (in Eclipse IDE top menu) &gt; Program Device &gt; Program (after ensuring that a valid bitstream is present for the Bitstream/PDI field). If it gives the same error, it is certainly about your board not being detected.</p> <p>If you get this error - \"Error while launching program: Memory write error at 0x0. Cortex-A53 #0: EDITR not ready\", run the following commands in the XSCT Console (bottom right in Debug perspective*) in Vitis Classic. This will set the boot mode to JTAG, which is what we want. This may need to be done once everytime the board is powered on.</p> <p></p> <pre><code>targets -set -nocase -filter {name =~ \"\\*PSU\\*\"}  \nmwr 0xff5e0200 0x0100  \nrst -system\n</code></pre> <p>Info</p> <p>If your program is inhibiting unpredictable behavior when dealing with large data, it could be due to stack or heap size limitations. You can increase the heap or stack size by editing the linker script (.ld file) which you can find in the project sources.</p> <p>References:</p> <p>https://support.xilinx.com/s/question/0D52E00006pW5zTSAS/error-memory-write-error-at-0x0-cortexa53-0-editr-not-ready-when-trying-to-debug-using-platform-cable-ii?language=en_US https://xilinx.github.io/kria-apps-docs/creating_applications/2022.1/build/html/docs/bootmodes.html</p> <p>*You can switch perspectives from Window &gt; Debug Perspective to go to debug, and\u00a0Window &gt; Design Perspective\u00a0to see Explorer, files, etc. You can also switch perspectives easily by selecting the required perspective on the top right as shown below.</p> <p></p> <p>For future runs until you disconnect the FPGA (or until you update the bitstream using Vivado), you can uncheck 'Reset Entire System' and 'Program FPGA, and click Apply. Otherwise, the FPGA will be re-programmed every time you run a program, which is not necessary. You can also leave these two options permanently unchecked if you program the FPGA through Xilinx Tools -&gt; Program FPGA.</p> <p>You should now be able to see the Hello World printed on RealTerm console (the exact message will be different).\u00a0</p> <p></p> <p>You can run again without opening up the Run configurations window by simply clicking the Run button as shown below.</p> <p></p> <p>Debugging can also be done to run step by step and inspect the variable values etc. You can also set breakpoints and all other debugging features. The same run configuration created above can also be used for Debug, you just need to click the Debug button.</p> <p></p> <p>It should automatically change perspective to Debug Perspective. If it prompts you if you want to go ahead, click OK. The program is now suspended at the first line of the main() function as shown below. You can use the standard debugging controls such as Resume, step over, step into, etc.\u00a0</p> <p></p> <p>Vitis does not auto-build before running/debugging. If you had changed your program, remember to build it before you debug / run it.</p> <p>Once done, Disconnect button in the Debug Perspective - either of the two places highlighted in the figure below. If this is not done, you may get a warning that a debug is ongoing.</p> <p></p>"},{"location":"Assignment_1/3_Using_Vitis_Classic/#beyond-hello-world-running-axi-stream-fifo-example-program","title":"Beyond Hello World : Running AXI Stream FIFO Example program","text":"<p>Go to drivers, and select the example for axi_fifo_mm_s_0 as shown in the figure below. This assumes a loopback connection in the block diagram / design we created in Vivado.</p> <p></p> <p>Run and see the results, which should show a success message in the Serial (UART) console.</p>"},{"location":"Assignment_1/3_Using_Vitis_Classic/#optional-exercise","title":"Optional Exercise","text":"<p>Simple input/output : Write a simple program in Vitis to read a character from the console and print that character to the console (echo).</p> <p>Essentially, you sent out a character from RealTerm console to PSU_UART1 on the Kria board. The C program running on ARM Cortex A53 reads it from the PSU_UART1 input buffer (using scanf or UART driver functions), and writes it to the PSU_UART1 output buffer (using printf or UART driver functions). The PSU_UART1 will send it over to the RealTerm console, which will then display it.</p>"},{"location":"Assignment_1/4_Serial_Console/","title":"Serial Console - RealTerm","text":"<p>RealTerm is a terminal program specially designed for capturing and sending data through various protocols (UART, Raw TCP sockets etc). The purpose is similar to that of TeraTerm or PuTTY or GTKTerm or Serial Monitor (Arduino), but RealTerm is WAAY more feature-rich than any other serial console program.</p> <p>The program can be downloaded from\u00a0https://realterm.i2cchip.com/Realterm_3.0.1.44_setup.exe. Older versions are fine too. The newer versions have more options and look slightly different from the screenshots on this page.</p> <p>If you are using FPGA locally, you need to configure the correct port and baud\u2010rate (115200) in RealTerm. This is shown in the figure below. Please ensure that Change is clicked after any port/speed modification. If you see strange-looking characters on your console, your baud rate setting in RealTerm is likely wrong.</p> <p></p> <p>The next step is to open the port. Click on Open to open the port. The status on the right should be green or gray, not red.</p> <p></p> <p>Note: Ensure that the port you are trying to connect to in RealTerm is not selected in Vitis.</p>"},{"location":"Assignment_1/4_Serial_Console/#few-notes-on-the-usage-of-realterm","title":"Few notes on the usage of RealTerm","text":"<p>Sending bytes using RealTerm: Click on the Send tab, type a number and click Send Numbers/Send ASCII. If you input, say 20 there and press Send Numbers, it will send 0x14. You can also enter directly as hexadecimal 0x14 and press Send Numbers.</p> <p>If you enter 20 press Send ASCII, it will send two characters 0x32 and 0x30. If you enter 0x14 and press Send ASCII, it will send 4 characters 0x30, 0x78, 0x31, 0x34 .</p> <p>You can also use escape sequences (special characters) such as \\r, \\n etc.</p> <p></p> <p>Sending text file contents using RealTerm: Specify the file in the Dump File to Port and click Send File.</p> <p></p> <p>Capturing data into a file using RealTerm: Click on Capture tab and specify the file where you want the output to be saved. Click on Start Overwrite.\u00a0 Check the Display option (available only in the newer versions) if you wish to see the data that is getting captured.</p> <p></p> <p>Explore the various features of RealTerm\u00a0and be familiar with it.</p> <p>The data can be displayed in a number of different formats, selectable from the Display tab. </p> <p>You can also click on the black part of the screen to send what you type, similar to how it is in TeraTerm/PuTTY etc. You can enable 'Half Duplex' in the Display tab if you like to see what you send out in a different color (green). The received data will be in yellow color.</p> <p>You can enable newLine mode if you wish the incoming formatting characters such as \\n to work as intended, instead of simply displaying it - RealTerm displays \\n as lf (linefeed) and \\r as cr (carriage return).</p> <p>It may be a good idea to uncheck 'Direct Capture' so that you can see everything that is received on the console even when you are capturing into a file.</p> <p>An editor such as Notepad++ can show you all characters in a file you are planning to send from RealTerm, including non-printable characters such as \\r (CR-carriage return) and \\n (LF-linefeed). You can view it by going to View&gt;Show Symbol&gt;Show All Characters in Notepad++. When sending using the 'Send ASCII' option in RealTerm, make sure you append \\r or \\n.</p>"},{"location":"Assignment_1/5_Performance_Analysis/","title":"Measuring Performance","text":""},{"location":"Assignment_1/5_Performance_Analysis/#axi-timer","title":"AXI Timer","text":"<p>How do we measure the exact time taken to execute a specific segment of software code?</p> <p>If the application is running on top of an OS (e.g. FreeRTOS), the OS typically provides some sort of system call / software timers. You could use this to log the timestamps at various points in your software code, which allows you to measure the execution times for various segments of your software code. You won't need specialized software tools or hardware (apart from the hardware timer that the OS needs) for this. However, the time resolution you get is typically not very high.</p> <p>We can also use a dedicated hardware timer to get the precise number of cycles required to execute a segment of software code. The difference between the counter readings before and after the segment of software code you want to analyze will give you the number of cycles, and hence the time taken. It is left entirely to you as a self-learning exercise.  This will require you to integrate an AXI Timer in your hardware (Vivado) and use the appropriate driver functions in Vitis. By now, you should have a hang of things and it should be easy enough as the timer/counter is a pretty simple peripheral. </p> <p>Make sure that you do not have any unnecessary code between the two points where you read the counter. For example, printing the first reading of the counter immediately after reading it would be a bad idea.</p> <p>A couple of hints:</p> <p>You need only one counter, whereas the timer IP block incorporates 2 counters by default. You can double-click the block in Vivado and uncheck the second one to reduce the hardware usage and synthesis time. You can get started with the xtmrctr_polled_example project for axis_timer_0 (tmrctr). You can get this from hardware_1_wrapper&gt;platform.spr&gt; Peripheral Drivers section of the Board Support Package. Try running this first, and later integrate the relevant parts into your software C code.</p>"},{"location":"Assignment_1/5_Performance_Analysis/#profiling","title":"Profiling","text":"<p>The process of collecting information about a program dynamically (i.e., during runtime) is called profiling. Many IDEs come with some sort of profiling tool.  There are a lot of different approaches to profiling.</p> <p>A typical way of doing profiling is to sample the program counter through the debug interface, which is supported by Xilinx/AMD tools - the TCF profiler is very easy to use - please try it out. Based on this, the profiler gives you statistics regarding what fraction (percentage) of time your program spends in each function. Profiling gives you clues regarding which function might be a good candidate for you to spend your time and money on - you wouldn't want to bother much about a function that is not a performance bottleneck. These improvements could be through algorithmic optimizations and/or hardware acceleration. Note: You need to do 'Debug' rather than 'Run' at least once for the profile option to be active. </p> <p>Note that you may need to loop the contents of each function (say, loopback_FIFO() vs matrix_multiply()) a huge number of times (after receiving the data just one time via the serial console*) to get a statistically meaningful comparison between these two when profiling using the TCF profiler.</p> <p>* It is a better idea to hardcode the arrays A and B in your program purely for performance analysis. This is so that the time required for receiving the data via serial console (UART) does not dominate. Comment out all printfs or other time-consuming functions that are not relevant to performance analysis - you can do so efficiently via <code>#define</code>-<code>#ifdef</code>-<code>#endif</code>.</p>"},{"location":"Assignment_1/6_Tips_Suggestions/","title":"Tips and Suggestions","text":"<p>Embedded system tools and boards have a relatively short lifespan - so you need to be able to pick up things on your own as and when required, often based on partial documentation and self-exploration. Lab 2 manuals have purposely left out detailed step-by-step instructions (esp. on the software part) - to let you explore the various options, think, search and find out things on your own. If you know precisely how to do it (that is, if we give you detailed steps), doing it shouldn\u2019t take you much time and is not worth 10% of you grades :D. Some tips are given below.</p> <p>You can do most of the testing of your C program logic without accessing the FPGA board. You can run it locally using a C/C++ IDE of your choice such as\u00a0Visual Studio Code or using an online compiler like\u00a0onlinegdb. Since the typical console (interface) you get cannot send files (such as A.csv and B.csv), you can copy-paste the file contents on the console, line by line, with the enter key pressed at the end of each line. If the console of the IDE you are using does not support copy-pasting, you will have to type it out. You can experiment with smaller matrices first to avoid wasting time doing too many copy-pastes.</p> <p>Sending data from RealTerm/Serial console every time can be time-consuming during the debug process. It is a good idea to have the required data (CSV file contents) hard-coded as an array in your C program, and use it during debugging. You could make use of #ifdef to conditionally use the hardcoded value or the live data streamed in from the serial console so that you can switch between them easily.</p> <p>There are 2 programs with interact with each other \u2013 the RealTerm program which runs on the PC, and your C program running on the board.</p> <p>RealTerm is a serial terminal / console program running on PC. It can send and receive characters, send and receive text files (text files are nothing but long strings) through the serial port (COM/tty) as well as network interfaces (TCP/IP sockets).</p> <p>The program running on the board (Cortex A53) receives the sequence of characters sent from the PC (you can use the send file option in RealTerm), does some computations, and sends it back to the PC (you can capture it into a file). Since this is running on the board which does not have direct access to the files on the PC, usual file related functions such as fopen() and fprintf() will not work!. You can only capture the stream of characters sent by the RealTerm, process it, and send back.</p> <p>Now the question on how to receive data sent from RealTerm in your C program - there are 2 approaches :</p> <p>Using stdin / stdout (The high-level way - easier but limited control)</p> <ul> <li>stdin and stdout are interfaces through which console-oriented functions such as\u00a0printf(), scanf(), getchar(), gets(), putchar(), puts() send data to be isplayed on\u00a0the console and receive data from the console.</li> <li>Since we have directed stdin and stdout to the console (where did we do that? - I leave it as an exercise for you to find out), you can use these functions to end and receive data from the PC/RealTerm.</li> <li>If the underlying physical layer is UART, the functions mentioned above such as printf() and scanf() makes use of UART driver functions under the hood, in addition to formatting/parsing the ASCII characters sent/received via UART. For example, the bytes 0x31, 0x32, 0x33, 0x0d if received via UART, scanf with a format specifier of \"%d\" will convert it to an integer 123.</li> <li>All the functions block until a\u00a0LF (linefeed - \\n) or CR(carriage return - \\r) is received. So you can't receive anything which is not properly terminated. When you send a file, make sure that it has a \\r or \\n character at the end of it. This is automatically inserted when you press 'enter' in a text file or console (Most Windows programs treat the press of 'enter' as \\r\\n, whereas in Linux, it is usually just \\n. For most console programs, it is '\\r' by default. These characters come from the typewriter era and mostly serve the same purpose on a computer).</li> </ul> <p>Using UART driver functions (The low-level way - great power, great responsibility)</p> <ul> <li>Gives you full control over what is sent and what is received to/from the console.</li> <li>You need to initialize the UART driver before you can use functions such as\u00a0XUartPs_Send() and\u00a0XUartPs_Recv() or the lower level XUartPs_SendByte() and\u00a0XUartPs_RecvByte().</li> <li>These are non-blocking functions (so you need to check the return value to see how many characters you have received) which give\u00a0you full control (no need for \\r or \\n).</li> <li>The basic procedure to deal with all hardware in the Xilinx toolchain is the same, as exemplified below through\u00a0XUartPs. You can go to your_bsp&gt;system.mss and see the driver documentation and examples.</li> <li>XUartPs Uart_Ps\u00a0//Declare a driver instance (not a pointer to this instance) as a global variable. All UART-related functions use a pointer to this instance.</li> <li>XUartPs_LookupConfig(DeviceId); // Looks up hardware instance info such as base address etc.\u00a0DeviceId is usually\u00a0XPAR_XUARTPS_0_DEVICE_ID, defined in xparameters.h.</li> <li>XUartPs_CfgInitialize(&amp;Uart_Ps,...)\u00a0// Initializes the hardware and driver instance</li> <li>XUartPs_SetBaudRate(&amp;Uart_Ps,...)\u00a0// Additional hardware specific settings/initializations. Following this, you can use the Send and Recv functions.</li> <li>Instead of starting from scratch, start with the examples from system.mss entry for the hardware you are looking at. For UART, you can probably start with\u00a0xuartps_hello_world_example and modify it to suit your needs.</li> </ul>"},{"location":"Assignment_2/1_HLSIntro/","title":"High Level Synthesis","text":"<p>Final</p> <p>This assignment description is now complete. There could still be minor updates, which will be highlighted. </p> <p>Follow the Spirit</p> <p>Some screenshots may be taken on other versions of Vivado/Vitis or for other configurations. The instructions could also vary slightly depending on the exact design/configuration you follow - such as whether you have separate or combined designs with multiple coprocessors / interfacing method (DMA/FIFO). The spirit of the instructions remain the same. Understand the significance of each step rather than following it mechanically.</p>"},{"location":"Assignment_2/1_HLSIntro/#introduction-to-high-level-synthesis","title":"Introduction to\u00a0High-level synthesis","text":"<p>High-level synthesis transforms C functions into hardware IPs.</p> <p>HLS works fairly well for inner blocks with fairly data-oriented (resource-dominated) functionality without complicated control flow structures. Examples would be digital signal processing, arithmetic on matrices, etc where loops have data-independent exit conditions.</p> <p>It is not very good for those outer blocks which typically involve complicated control structures (control dominated). HLS-based generation of a control-dominated circuit such as a microcontroller is a holy grail.</p> <p>The HLS tool is temperamental - sometimes you get very good results, and sometimes you end up wondering what just happened. Sometimes even slight code changes that should have little/no functional relevance can produce substantially different hardware. Well, using an inherently sequential high-level language to produce inherently parallel hardware is challenging.</p> <p>Not all C code can be synthesized. Anything that depends on a runtime environment\u00a0would not work. An example would be dynamic memory allocation\u00a0(no malloc). Keep in mind that the goal of HLS is not to create something which executes on a processor, it is to create a sort of a processor itself.</p> <p>Creating an HLS-based design based on default options might not yield a good IP/hardware. It will be kind of like going on an organized tour. You will get some feel of the place, you will have the bragging rights, but the experience is generally not so 'authentic'. You need to exert control of the hardware generated using various optimization directives as appropriate depending on the context, design requirements/ tradeoffs.</p> <p>The accelerator IP that we create needs to be interfaced with the rest of the system (that you created in Assignment 1) for the processor to make it act as a coprocessor. The interface of the IP generated by the HLS can be</p> <p>Register-based: The processor can read and write the registers within the coprocessor to write inputs/read outputs - each register has an address within the address space of the processor. The parameters and return values are mapped to these registers/addresses. For example, A is in the offset range 0xx to 0xyy - the actual address range is the base address of the coprocessor peripheral (assigned in Vivado under the address tab) + the offset. The coprocessor in this case has an AXI or AXI Lite interface which can be connected to the AXI bus of the system as a slave (similar to how the timer was connected in Assignment 1).</p> <p>Stream-based: There are separate input and output streams through which the data is streamed in/out. There is no concept of addresses, and the meaning of the data is derived from the order of the data (and possibly some 'tags'). For example, the first 512 words correspond to A, the next 64 correspond to B, and so on. Please read the Introduction to AXI Stream page.</p> <p>Memory-based: The co-processor reads inputs from / writes output to memory directly. For now, we will start with Stream-based which is perhaps the easiest to get started. </p>"},{"location":"Assignment_2/1_HLSIntro/#assignment-2","title":"Assignment 2","text":"<p>The template/data files are here.</p> <p>The assignment involves</p> <p>1) Creating a stream-based coprocessor aka accelerator do matrix multiplication (RES=A*B/256) using HLS and integrating it into the system. The matrix multiplication problem is exactly the same as in Assignment 1 (the part of your program to send the matrices A and B from PC can be commented out and the matrices can be hard-coded in your program for convenience), just that the multiplication should now be offloaded to the coprocessor in addition to doing it purely in software. </p> <p>You should do coprocessor Interfacing using both AXI Stream FIFO and AXI DMA. Try with FIFO first before venturing into DMA. It is not necessary that AXI Stream FIFO and AXI DMA-based interfacing has to be done as a single system, i.e., it is fine to have separate projects for each case. Of course, combining those into a single project is fine as well - this page might give you some ideas. </p> <p>2) Further, for each case above, you need to compare the hardware and software performance via profiling (TCF Profiler, mentioned in the page on Performance analysis) as well as using AXI Timer.</p> <p>The time taken for the hardware version should be inclusive of the time taken for sending data to and receiving data from the coprocessor (i.e., writing to / reading from AXI Stream FIFO), as this is an unavoidable overhead associated with offloading computations to hardware. This overhead can possibly be ignored when using DMA in a non-blocking fashion, i.e., the CPU is performing some other useful task while the DMA data transfer and co-processor computations are in progress.</p> <p>It is suggested that you create separate functions called from the main program - something like matrix_multiply_soft(), matrix_multiply_FIFO(), matrix_multiply_DMA) for the software and the hardware versions (using FIFO and DMA) respectively. This facilitates profiling using the TCF profiler which can do profiling only at a function level.</p> <p>The time taken for sending and receiving data via UART should not be considered, as it has nothing to do with computation/hardware acceleration. It is suggested that the data is hard-coded as a C-array rather than receiving it via UART for this assignment.</p> <p>3) You are also required to try at least one possible optimization in HLS and compare the performance on hardware (which wouldn't require any modifications to your software C code) with the vanilla (non-optimized) version. The C code for HLS needs to have appropriate pragmas inserted manually or graphically. This is a self-learning / self-exploration exercise.</p> <p>You should read and get an overview of the following 4 optimizations from the document https://docs.amd.com/v/u/en-US/ug1270-vivado-hls-opt-methodology-guide. The page numbers below are the pages where the topic starts, not necessarily the only 4 pages you need to read. These were covered in the lecture on a conceptual level.</p> <ul> <li>pragma HLS array_partition....83</li> <li>pragma HLS dataflow...............91</li> <li>pragma HLS pipeline................116</li> <li>pragma HLS unroll....................125</li> </ul> <p>Note that while these optimizations are applied independently, some optimizations work well only when some other optimizations are also used. For example, doing pipelining or loop unrolling without partitioning the array wouldn't help much, as the bottleneck will be accessing the memory, 1 or 2 elements at a time. The effect of these optimizations is not always that deterministic though, given the nature and non-maturity of HLS tools. </p> <p>Newer versions of Vitis perform some of these optimizations (e.g., pipelining, array partitioning) automatically provided certain conditions are met. You can disable this from the settings or via pragmas to see the performance of the non-pipelined versions.</p> <pre><code>#pragma HLS pipeline off\n</code></pre> <p>It can also be done via tcl.</p> <pre><code>set_directive_pipeline -off [get_loops \"loop_label\"]\n</code></pre> <p>and also via hls_component &gt; settings &gt; hls_config.cfg &gt; C Synthesis &gt; Compile &gt; compile.pipeline_loops to 0 (hls component and config file names to be changed as appropriate).</p> <p>The dataflow optimisation by itself will likely not yield any improvement in performance without modifying the software (C program) significantly to take advantage of the hardware optimisations. This is not easy, and will ideally need an operating system (e.g., FreeRTOS that is supported out of the box), and hence is a purely optional exercise.</p> <p>When evaluating the effect of HLS optimisations, you can choose either AXI Stream FIFO and AXI DMA-based interfacing, but the latter is strongly recommended. As is the case with FIFO and DMA based designs, it is fine to have separate projects or a combined project for the designs with and without optimisations.</p> <p>To summarise, we have 3 scenarios. We can have either a single project combining all the 3 above, or 3 separate projects.</p> <ul> <li>Non-optimised coprocessor interfaced using FIFO.</li> <li>Non-optimised coprocessor interfaced using DMA.</li> <li>Optimised coprocessor interfaced using DMA/FIFO (DMA recommended).</li> </ul>"},{"location":"Assignment_2/1_HLSIntro/#submission-info","title":"Submission Info","text":"<p>Assignment 2\u00a0(10 marks)</p> <p>Upload .zip file containing the</p> <ul> <li>the .cpp files used for HLS implementation and test/co-simulation. The directives.tcl file should also be included if the 'Directive Destination' is 'Directive File' instead of 'Source File'.</li> <li>.C/H file(s) running on ARM Cortex A53 used to send data to the co-processor, including timer (only those you have modified).</li> <li>A screenshot of your IP integrator canvas, i.e., the block diagram (please do not upload the entire Vivado project folder) for each case (or combined).</li> <li>.xsa file(s).</li> <li>A text file containing the information printed on the serial console in each case (or combined).</li> <li>Screenshots of the TCF profiler tab showing the comparisons in each case (or combined).</li> </ul> <p>to the Canvas by 11:59 PM, 4 Oct 2025. The exact same files should be used for evaluation.</p> <p>It should be as a .zip archive, with the filename  &lt;Team number&gt;_&lt;Team member 1 Name&gt;_&lt;Team member 2 Name&gt;_Asst2.zip.</p> <p>Please DO NOT upload the whole project!</p> <p>You will also need to do an online demonstration to a teaching assistant (based on what you submitted at the point of the assignment deadline, not the version you may have improved after the deadline) - arrangements will be made known in due course.</p>"},{"location":"Assignment_2/1_HLSIntro/#references","title":"References","text":"<p>Here are some references that can help you get started with Vivado\u00a0High-Level\u00a0Synthesis\u00a0tool</p> <ul> <li>A good Xilinx official presentation on optimization</li> <li>HLS Introduction from Xilinx/AMD</li> <li>Vitis Design Hub - High-Level Synthesis. The documents here are very very useful.</li> <li>Vivado HLS flow on Zynq workshop: \u00a0just register for a Xilinx account then you can download all the material for the workshop. After finishing all the labs, you should be able to apply HLS to your project.</li> <li>Parallel Programming for FPGAs\u00a0: A very good free textbook on HLS (http://kastner.ucsd.edu/hlsbook/).</li> </ul>"},{"location":"Assignment_2/2_HLSFLow/","title":"HLS Flow","text":""},{"location":"Assignment_2/2_HLSFLow/#introduction","title":"Introduction","text":"<p>The following manual is for Vitis (Visual Studio Code based) unified IDE. The spirit of the instructions is quite similar for Vitis HLS (eclipse-based, which is being deprecated), if you wish to use that.</p> <p>You will need the template files\u00a0myip_v1_0_HLS.cpp (CPP source for HLS) and\u00a0test_myip_v1_0_HLS.cpp\u00a0(Testbench).\u00a0The sample program receives 4 numbers, computes the sum, and sends back 4 numbers, which are sum, sum+1, sum+2, and sum+3.\u00a0Read through these files and understand the implementation. You will notice that test_myip_v1_0_HLS.cpp is very similar to the other test programs that we have used. Have a good look at the similarities and differences.</p> <p>test_myip_v1_0_HLS.cpp is a testbench used for simulation only. It is not executed on the ARM Cortex A53 processor on the board. We will be doing 2 types of simulation.</p> <ul> <li>C simulation.</li> <li>C simulation executes a pure software version of the files, where\u00a0myip_v1_0_HLS.cpp simply contains the function myip_v1_0_HLS() that is called by the main program in test_myip_v1_0_HLS.cpp. This is a very fast process, used to check the algorithmic correctness.</li> <li> <p>RTL/C Cosimulation</p> </li> <li> <p>Here, instead of calling myip_v1_0_HLS() as a function, the corresponding RTL (=HDL) code generated through C Synthesis (=HLS) is simulated using the Vivado simulator (XSIM) behind the screens. This takes more time than C simulation (orders of magnitude more time for complex designs) and is used to test the functional correctness of the HDL generated by the HLS process. The test_myip_v1_0_HLS.cpp feeds data directly into the (simulated) S_AXIS of the coprocessor, and gets data directly from the (simulated) M_AXIS of the co-processor. AXI bus and AXI Stream FIFO are not involved.</p> </li> </ul> <p>test_fifo_myip_v1_0.c. is executed on the ARM Cortex A53 processor of the board, and exchanges data with the real coprocessor through the AXI Stream FIFO.</p>"},{"location":"Assignment_2/2_HLSFLow/#creating-and-synthesizing-a-design","title":"Creating and Synthesizing a Design","text":"<p>Open Vitis.</p> <p>Select Open Workspace. Select a freshly created folder (create a folder using your operating system's file manager, e.g., explorer) for the HLS IP. If you are opening an existing design, you can also select it under Recent Workspaces.</p> <p></p> <p>Select\u00a0Create HLS Component. Specify a name (myip_v1_0_HLS) and path/location that doesn't involve underscores or spaces. Next.</p> <p>Accept the defaults for the Configuration File and click Next.</p> <p>In the Add Source Files dialog, add the design file (myip_v1_0_HLS.cpp), testbench (test_myip_v1_0_HLS.cpp), and the top function.</p> <p></p> <p>It may take a few seconds after you click Browse in step 3 above before the top function myip_v1_0_HLS appears as an option. Select it and click ok.</p> <p></p> <p>Note that the above files will remain in their original location and won't get copied over to the project, there is no option to easily copy it over to the project. The files should be in a location that doesn't involve underscores or spaces.\u00a0Next.</p> <p>In the part number selection, search for xck26 and select xck26-sfvc784-2LV-c (which is the part number for the chip used on board). Next.</p> <p>Note: You may also be able to find it easily under Boards &gt; Kria KV260 Vision AI Starter Kit in Vitis HLS, but not in Vitis.</p> <p></p> <p>Enter 10ns or 100MHz, without a space between the quantity and the unit. Make sure that the rest of the settings are as below, which should be the case by default. Next.</p> <p></p> <p>Next. Finish.</p> <p>You will see myip_v1_0_HLS.cpp file under myip_v1_0_HLS&gt;Sources, and test_myip_v1_0_HLS.cpp under Test Bench in the workspace. Ensure that the contents are as expected. Later on, you need to modify these files as appropriate to implement assignment 4.</p> <p></p> <p>You can see all the settings under myip_v1_0_HLS&gt;Settings &gt; hls_config.cfg.</p> <p></p> <p>Under FLOW, Run C SIMULATION. This tests your program as standard software - an executable is created and run.</p> <p>If running Ubuntu and C simulation fails, do <code>sudo apt install build-essential</code> to install gcc and other tools that Vitis HLS depends on, but aren't installed by the installLibs.sh script (!).</p> <p></p> <p>You can see that it completes successfully in the output console of VS Code (Vitis).</p> <p></p> <p>Now, run C SYNTHESIS. Once done, you can see the success message in the output console.</p> <p>You can now explore the various reports under C SYNTHESIS &gt; REPORTS.</p> <p></p> <p>Of particular interest are</p> <ul> <li>Synthesis &gt; Timing Estimate, Performance &amp; Resource Estimates.</li> <li>Schedule viewer (the result of the scheduling step in architectural synthesis, screenshot not shown here).</li> </ul> <p></p> <p>You can also see the HDL files generated by the HLS tools under myip_v1_0_HLS&gt;Output folder in the workspace.</p> <p></p> <p>Now, run C/RTL COSIMULATION. Once done, you can see the success message in the output console.</p> <p>This runs the HDL (RTL) code using the Vivado (XSIM) simulator, using the stimulus provided by the C testbench. You can see the success message in the output console.</p> <p>Finally, run PACKAGE. Once done, you can see the success message in the output console. The IP is now ready to be used in the Vivado project.</p> <p>Open Vivado. Create / Open a project (you can use a copy of Assignment 1 if you wish). Add your Vitis workspace to the IP repository.</p> <p></p> <p>That is it. Now you will be able to see the IP in the IP catalog.</p> <p></p> <p></p> <p>Make the S_AXIS and M_AXIS connections to AXI Stream FIFO / AXI DMA. Clock and reset can be connected via connection automation.</p> <p>The rest of the process is standard - create HDL wrapper (if not set to auto-update) &gt; Generate Bitstream&gt; Export Hardware (including bitstream). The rest is in Vitis. The exact same Vitis project can be used (including all the source files), with the .xsa file refreshed.</p>"},{"location":"Assignment_2/2_HLSFLow/#optimizing-the-design","title":"Optimizing the Design","text":"<p>This section details how you can control the\u00a0hardware / architecture\u00a0generated using directives. These directives can be inserted as #pragma in your C-code, or graphically as shown below.</p> <p>Open the HLS Directive view on the right. Note that the directive view as shown below will appear only when the myip_v1_0_HLS.cpp is selected in the editor window. You can see that some directives that were in the template code, such as the HLS INTERFACE directive appear in the list of directives.</p> <p>Select the part of the code whose hardware architecture you wish to control, for example, the for loop myip_v1_0_HLS_for1 below. We already had a label myip_v1_0_HLS_for1 for the for loop in our source code for easy identification but is not mandatory*.</p> <p></p> <p>Select the directive. Here, we UNROLL the for loop selected above. You can also set the optional parameters, such as the unroll factor for UNROLL. You can choose whether the directive is to be inserted into the code as a #pragma, or to be inserted into the config file. We choose the former for now.</p> <p></p> <p>You can now see the directive in the source code.</p> <p></p> <p>*A label is necessary if we are inserting the directive into the config file. If you choose to insert the directive into the config file, you can see it as follows.</p> <p></p> <p>Run C Synthesis again. You can see that the timing, performance (latency) &amp; resource (FF, LUT, etc) estimates have changed.</p> <p>Try separately with arbitrary precision and 32-bit precision by commenting/uncommenting the relevant lines in myip_v1_0_HLS.cpp. Do you notice a difference in timing, performance &amp; resource estimates once you run C synthesis?</p>"},{"location":"Assignment_2/3_FIFO/","title":"Coprocessor Integration using AXI Stream FIFO","text":"<p>You can read more about AXI Stream FIFO on AMD website (please do!).</p> <p>When we use AXI Stream FIFO as the bridge, the processor reads the operands from the memory (RAM) and writes them to the transmit FIFO in AXI Stream FIFO peripheral via AXI (not AXI Stream), which in turn passes it to the coprocessor via AXI Stream. The result returned by the coprocessor gets deposited into a receive FIFO in AXI Stream FIFO peripheral, from which the processor reads it via AXI (not AXI Stream) and writes it to the memory (RAM).</p> <p>This manual assumes that we are using the custom HLS-generated IP for adding 4 numbers as mentioned in the HLS Flow page. It has two AXIS interfaces - S_AXIS for sending data, and M_AXIS for receiving data. Even if the coprocessor functionality is different, the interface is still the same, and hence the procedure below applies.</p> <p>Let us assume you are starting with your Assignment 1 Vivado project as shown below, with the AXI Stream FIFO peripheral already included. If not, include AXI Stream FIFO following the instructions in Assignment 1. Also, note that the connection from the interrupt of axi_fifo_mm_s_0 to pl_ps_irq0 of zynq_ultra_ps_e_0 is optional, only if you want to use interrupts.</p> <p>The following instructions also assume that the coprocessor is already added/available in the IP Integrator canvas. If not, add it from the IP Catalog.</p> <p></p> <p></p> <p>Note that the IP may look slightly differently depending on the version of Vitis, and the exact way it was created.</p> <p>Now, make/modify the following connections.</p> <p>Delete the connection from axi_fifo_mm_s_0/AXI_STR_TXD to axi_fifo_mm_s_0/AXI_STR_RXD</p> <p>Connect myip_0/M_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD</p> <p>Connect myip_0/S_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_TXD</p> <p>You can now run the connection automation that will connect the ACLK and ARESETN of myip_0 :</p> <p>myip_0/ACLK &lt;-&gt; zynq_ultra_ps_e_0/pl_clk0</p> <p>myip_0/ARESETN &lt;-&gt; rst_ps8_0_99M/peripheral_aresetn</p> <p>You can click regenerate layout to tidy up.</p> <p></p> <p>You can now save the block design (Ctrl+S) and generate bitstream.</p> <p>The rest of it is similar to Assignment 1.</p> <p>You need to export hardware, including bitstream.</p> <p>Open Vitis &gt; create a new workspace (using the previous one is also ok) &gt; create a new platform project using the new .xsa file (upgrading the previous one is ok too), &gt; create an application project.</p> <p>The application project (say, Hello World) main file contents should be replaced by test_fifo_myip_v1_0.c to test the coprocessor for adding numbers. You can make appropriate changes to this file to deal with different input and output sizes if your coprocessor functionality is different.</p> <p>Now, create a run configuration, open the serial console program (e.g., RealTerm), and run.</p> <p>If you wish to use interrupts, you need to make sure that there is a connection from the interrupt of axi_fifo_mm_s_0 to pl_ps_irq0 of zynq_ultra_ps_e_0. There is a built-in example program for axi_fifo_mm_s using interrupts, which can be combined appropriately with test_fifo_myip_v1_0.c to have interrupt-based communication. However, note that interrupts are useful only if the processor is doing some other meaningful work while the coprocessor is doing computations.</p>"},{"location":"Assignment_2/3_MultipleCoPro/","title":"Connecting Multiple Coprocessors (Optional)","text":"<p>This document describes how you can (optional) connect multiple coprocessors to your system.</p> <p>It is possible to connect 2 coprocessors through 2 AXI FIFOs (or AXI DMAs). This is not a requirement, but not a bad idea as you can compare the various implementations in one go. You just need to add one more AXI Stream FIFO IP from the IP catalog and make connections the same way you did for the first one. On the C side, the following should help. A similar idea can be used if you have 2 coprocessors connected through 2 AXI DMAs (or for any two instances of the same IP for that matter).</p> <p>General Idea</p> <p>The code below is to illustrate the general idea. Appropriate changes will be necessary depending on the specific peripheral being duplicated as well as the version of Vitis used.</p> <pre><code>XLlFifo FifoInstance0; \u00a0 \u00a0 // Device 0 instance\nXLlFifo *InstancePtr0 = &amp;FifoInstance0; // Device 0 pointer\nXLlFifo FifoInstance1; \u00a0 \u00a0 // Device 1 instance\nXLlFifo *InstancePtr1 = &amp;FifoInstance1; // Device 1 pointer\n\u00a0\nint main()\n{\n\u00a0 \u00a0 int Status0 = XST_SUCCESS; // can also use just a single status variable.\n\u00a0 \u00a0 int Status1 = XST_SUCCESS;\n\u00a0\n\u00a0 \u00a0 XLlFifo_Config *Config0; // can also reuse the config pointer instead of having two.\n\u00a0 \u00a0 XLlFifo_Config *Config1;\n\u00a0\n\u00a0 \u00a0 /* Initialize the Device Configuration Interface driver for FIFO0 */\n\u00a0 \u00a0 Config0 = XLlFfio_LookupConfig(XPAR_AXI_FIFO_MM_S_0_BASEADDR);\n\u00a0 \u00a0 if (!Config0) {\n\u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"No config found for %d\\r\\n\", XPAR_AXI_FIFO_MM_S_0_BASEADDR);\n\u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 Status0 = XLlFifo_CfgInitialize(InstancePtr0, Config0, Config0-&gt;BaseAddress);\n\u00a0 \u00a0 if (Status0 != XST_SUCCESS) {\n\u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"Initialization failed\\r\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 \u00a0/* Initialize the Device Configuration Interface driver for FIFO1 */\n\u00a0 \u00a0 Config1 = XLlFfio_LookupConfig(XPAR_AXI_FIFO_MM_S_1_BASEADDR);\n\u00a0 \u00a0 if (!Config1) {\n\u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"No config found for %d\\r\\n\", XPAR_AXI_FIFO_MM_S_1_BASEADDR);\n\u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 Status1 = XLlFifo_CfgInitialize(InstancePtr1, Config1, Config1-&gt;BaseAddress);\n\u00a0 \u00a0 if (Status1 != XST_SUCCESS) {\n\u00a0 \u00a0 \u00a0 \u00a0 xil_printf(\"Initialization failed\\r\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 return XST_FAILURE;\n\u00a0 \u00a0 }\n\u00a0\n\u00a0 \u00a0 Status0 = XLlFifo_Status(InstancePtr0); /* use the correct driver pointer \n                        depending on the device instance you are interacting with.*/\n\u00a0 \u00a0 Status1 = XLlFifo_Status(InstancePtr1);\n</code></pre>"},{"location":"Assignment_2/4_DMA/","title":"Coprocessor Integration using AXI DMA","text":"<p>In this page, you will learn to integrate the AXIS coprocessor using AXI Direct Memory Access (DMA) instead of AXI FIFO. We will use the simple AXIS coprocessor created and packaged using HLS. It is a good idea to have the functionality tested using AXI Stream FIFO first.</p> <p>When using AXI DMA, the processor only supplies (via AXI Lite, not AXI Stream) the starting address and the size/amount of data to be transferred from the memory to the coprocessor (or vice versa), and it is the DMA controller that reads memory directly and passes it to the coprocessor via AXI Stream (or vice versa). The processor is not involved in the transfer of data directly, i.e., it does not do repeated load-store (LDR/lw-STR/sw) to do bulk data transfer.</p> <p>Here, we will be using the Xilinx AXI DMA IP as the module that connects the coprocessor to the rest of the system. You can find the specification of AXI DMA here.</p> <p>You can start with a new project or from an existing project. As most of you would be reaching this step from an existing project, which would have the coprocessor connected using AXI Stream FIFO. In the future, if you are starting a new project and plan to use AXI DMA, you do not need AXI Stream FIFO in your design at all. It is also fine to delete AXI Stream FIFO from the project (instructions later), which can save some hardware and synthesis time. </p> <p>It is perfectly fine to retain AXI Stream FIFO + coprocessor, and use another instance of the coprocessor for DMA, if you are doing a combined design, i.e., a single design with FIFO-connected coprocessor + one or more DMA-connected coprocessors.</p> <p>On this page, however, we keep the AXI Stream FIFO and connect it in loopback mode, rendering it vestigial.</p> <p>The following instructions also assume that the coprocessor is already added/available in the IP Integrator canvas. If not, add it from the IP Catalog.</p> <p></p> <p>Now, make/modify the following connections of AXI Stream FIFO.</p> <p>Delete myip_0/M_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD connection.</p> <p>Delete myip_0/S_AXIS &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_TXD connection.</p> <p>Make a connection from axi_fifo_mm_s_0/AXI_STR_TXD &lt;-&gt; axi_fifo_mm_s_0/AXI_STR_RXD. This will make the AXI Stream FIFO in loopback mode and hence useless.</p> <p>Alternative: Delete the AXI Stream FIFO peripheral altogether. This can be done by simply selecting the block via single-click and pressing delete (or from the right-click menu). If you do so, you need to double-click the AXI Interconnect and reduce the number of Master interfaces by 1; e.g., if it was originally 3, we need to make it 2; if it was originally 2, we need to make it 1. This is because the AXI Stream FIFO peripheral has two AXI slave interfaces (S_AXI and S_AXI_FULL, as we enabled AXI as well in addition to the original AXI Lite interface), whereas AXI DMA requires only one AXI slave interface (S_AXI_LITE).</p> <p>This can cause some existing AXI slave connections to be broken (e.g., M0x_AXI of the AXI Interconnect to S_AXI of the peripheral), which can be easily fixed via connection automation.</p>"},{"location":"Assignment_2/4_DMA/#connecting-the-coprocessor-using-dma","title":"Connecting the Coprocessor using DMA","text":"<p>From the IP catalog, add the peripheral titled AXI Direct Memory Access. Double-click it,\u00a0uncheck\u00a0Enable Scatter Gather Engine, and click OK. It will look like the figure below.</p> <p></p> <p>The\u00a0S_AXI_LITE\u00a0is the AXI-Lite slave interface that receives the commands (how much data is to be transferred from/to which address etc) from\u00a0the ARM core in PS. Running connection automation will connect it, as well as the s_axi_lite_aclk and axi_resetn.</p> <p>MM2S: When data has to be transferred to the coprocessor, the ARM core specifies the range of memory (starting address, size of data to be sent) to the DMA peripheral by writing to the DMA peripheral registers through the S_AXI_LITE interface. The DMA controller reads the memory via the M_AXI_MM2S interface (this is the AXI master interface, which has only read\u00a0channels), and sends the data to the\u00a0S_AXIS of the coprocessor via the M_AXIS_MM2S.</p> <p>S2MM: When data has to be received from the coprocessor, the ARM core specifies the range of memory (array starting address, length of data to be received) to the DMA peripheral by writing to the DMA peripheral registers through the S_AXI_LITE interface. The DMA controller receives the data from M_AXIS of the coprocessor via the S_AXIS_S2MM, stores it in an internal buffer, and then writes it to the memory via the M_AXI_S2MM interface (this is the AXI master interface, which has only write\u00a0channels).</p> <p>First, make the M_AXIS_MM2S &lt;-&gt;S_AXIS and M_AXIS &lt;-&gt; S_AXIS_S2MM connections to connect the coprocessor/myip and the DMA.\u00a0You can now run connection automation, which will connect ACLK and ARESETN of myip.</p> <p>The DDR memory controller is implemented in the PS, which requires a slave AXI interface in PS to receive the address and read/write commands from the AXI DMA master interfaces, i.e., M_AXI_S2MM and M_AXI_MM2S. For this, we need to enable one of the Slave Interface &gt; AXI HP (let's say, AXI HPC0 FPD) in the PS-PL configuration of the Zynq Ultrascale+ MPSoC IP/zynq_ultra_ps_e_0. Double-click the Zynq PS IP &gt; PS-PL Configuration&gt; Slave Interface &gt; AXI HP &gt; AXI HPC0 FPD, and then OK. A new interface called S_AXI_HPC0_FPD will appear on the Zynq Ultrascale+ MPSoC IP block diagram in the IP Integrator canvas.</p> <p></p> <p>We now need to connect M_AXI_S2MM and M_AXI_MM2S to S_AXI_HPC0_FPD. This will have to be done using an AXI Interconnect or AXI SmartConnect. This can be done through connection automation twice. When you run the connection automation once, it will make only one connection - M_AXI_MM2S\u2192 S_AXI_HPC0_FPD (if M_AXI_MM2S is selected in Options &gt; Master Interface in the connection automation dialog), and the corresponding m_axi_mm2s_aclk. The connection automation banner will still be there. Run connection automation again. This time, it will add an interconnect and make the M_AXI_S2MM\u2192 S_AXI_HPC0_FPD, as well as the m_axi_s2mm_aclk connection.</p> <p>*AXI Interconnect and AXI SmartConnect are functionally similar. The latter is newer and more optimized, though the connection automation does not always include it.</p> <p>Overall, the connections should be as shown below, at least those relevant to AXI DMA. There could be differences in the overall block design and connections depending on the exact peripherals you have in the design.</p> <p></p> <p>Have a look at the Address Editor tab too. It should generally be fine as long as the AXI (not AXIS - AXIS connections were done manually anyway and have no concept of addresses/memory map) connections are done via connection automation. If there were any manual modifications you made to AXI connections, appropriate manual modifications may be needed here.</p> <p>In particular, ensure that in which zynq_ultra_ps_e_0 is the master, all S_AXIs are given proper, non-conflicting addresses. Also, ensure that in the network where axi_dma_0 is the master, S_AXI_HPC0_FPD with the slave segment HPC0_DDR_LOW is included (i.e., not excluded) for both axi_dma_0/Data_MM2S as well as axi_dma_0/Data_S2MM. This is to ensure that the AXI DMA peripheral can read as well as write (respectively) the DDR memory.</p> <p></p> <p>We are done with the block design.</p> <p>The rest of it is pretty standard, and you should know the drill by now.</p> <p>Export hardware, including bitstream.</p> <p>Open Vitis &gt; create a new workspace (using the previous one is also ok) &gt; create a new platform project using the new .xsa file (upgrading the previous one is ok too), &gt; create an application project.</p> <p>The application project (say, Hello World) main file contents should be replaced by test_dma_myip_v1_0.c to test the coprocessor for adding numbers. Note the close parallel it has with test_fifo_myip_v1_0.c.\u00a0You can make appropriate changes to this file to deal with different input and output sizes if your coprocessor functionality is different.</p> <p>Now, create a run configuration, open the serial console program (e.g., RealTerm), and run.</p> <p>You can also use interrupts like that described for AXI Stream FIFO.</p> <p>The built-in (BSP) example (simple poll) works too with appropriate modifications, but it uses hard-coded addresses and uses memory locations without allocating memory in the code. Cache-related stuff becomes quite messy if the invalidation has side effects, that is, other variables in the same cache block get affected. So keeping it away from the range of memory used by the rest of the program is a reasonably good choice, though this kind of memory allocation will make a memory safety advocate cringe (but ok considering that user-level programs typically do not do DMA directly - it is typically an OS function).</p> <p>Debugging tip: DMA in a system with cache enabled gives several headaches. Throw interrupts into the mix, and you could run into some hard-to-debug issues. One simple starting point in debugging DMA-related issues is to uncomment Xil_DCacheDisable(). If things work, the issues are cache-related. Of course, you wouldn't want to leave the cache disabled in a real-world system for performance reasons, but it would be a good first step in debugging DMA-related issues.</p>"},{"location":"Assignment_2/4_DMA/#axi-dma-vs-axi-stream-fifo","title":"AXI DMA vs AXI Stream FIFO","text":"<p>AXI DMA implemented this way, while still likely faster than AXI Stream FIFO, won't be making full use of\u00a0 DMA's potential. In our case, the CPU is doing nothing while waiting for the DMA transfer to finish. In a more real-life scenario, the CPU will execute something else (another thread) in the meantime, using the data present in the cache, or through some form of intermittent memory access - read here. The thread that is waiting for the DMA transfer to complete will be woken up only when the DMA controller raises an interrupt to signal to the CPU that the transfer is complete.</p> <p>Another couple of questions to ponder:</p> <ul> <li>AXI DMA does not need a buffer (and certainly not a big internal buffer), unlike AXI Stream FIFO. Why?</li> <li>AXI DMA has an AXI LITE interface, whereas AXI Stream FIFO should have a full AXI interface for performance reasons. Why?</li> </ul>"},{"location":"Assignment_2/5_ModifyCoPro/","title":"Modifying the Coprocessor","text":"<p>Once you update your IP using HLS and come back to your main Vivado project, it will show a banner that 'IP Catalog is Out of Date' or 'myip_0 should be upgraded'. If it is the former, click\u00a0Rerun\u00a0in the IP Status Tab below. If it is the latter, clicking Report IP Status / Show IP Status will open up the IP Status Tab. Either way, after myip_0 is selected, click\u00a0Upgrade Selected.</p> <p>If the 'IP Status' tab does not appear, make sure that the IP Integrator is selected in the Flow Navigator, and Reports (top menu bar) &gt; Report IP Status.</p> <p>An IP Upgrade Completed will pop up once the IP is successfully upgraded.\u00a0When you dismiss the message by clicking OK, it will show up a Generate Output Products window.\u00a0Click\u00a0Generate. Once the output products are generated, click OK to dismiss the message.\u00a0 The IP Status will again show that one or more IPs have changed. Click\u00a0Rerunagain (the second time is for regenerating reports), but you need not (and won't be able to) click Upgrade Selected this time.</p> <p>You can check if the IP is updated by following the screenshot below.</p> <p></p> <p>Now, you can go ahead andGenerate Bitstream.</p> <p>Once the hardware is generated, Export &gt;\u00a0Export Hardware. Don't forget to\u00a0Include bitstream.</p> <p>However, a new .xsa file will not cause the platform project to be modified automatically.</p>"},{"location":"Assignment_2/5_ModifyCoPro/#vitis","title":"Vitis","text":"<p>In Vitis, select the Switch / re-read XSA option as shown in the screenshot below. You will be required to browse to the updated file followed by select/OK. It will take a short while to re-read the .xsa file.</p> <p>Once this is done, build the platform project again.</p> <p></p> <p>If you run into issues, Regenerate BSP as shown in the screenshot below.</p> <p></p> <p>If that doesn't work either,\u00a0create a new workspace, and then an application project using the new .xsa file. Copy over your C code to the new project.</p> <p>If it still shows the old coprocessor functionality, you might want to try deleting intermediate files in Vivado and regenerating the bitstream.</p>"},{"location":"Assignment_2/5_ModifyCoPro/#vitis-classic","title":"Vitis Classic","text":"<p>For Vitis Classic, right-click on the hardware platform as shown in the figure below. You will be required to browse to the updated .xsa file, followed by two OKs.</p> <p></p> <p>Then build the platform project (e.g., design_1_wrapper).</p> <p></p> <p>The Vitis Classic project doesn't always get updated that properly. If you run into issues, Reset BSP Sources as shown in the figure below, and build the hardware and application projects.</p> <p></p> <p>If that doesn't work either,\u00a0create a new workspace, and then an application project using the new .xsa file. Copy over your C code to the new project.</p> <p>Don't forget to\u00a0program the FPGA again\u00a0before running your code (which will be done automatically if the option to Program FPGA is checked in Run Configurations), as the hardware has now changed!</p> <p>If it still shows the old coprocessor functionality, you might want to try deleting intermediate files in Vivado and regenerating the bitstream.</p>"},{"location":"Assignment_3/1_OpenCL_Intro/","title":"OpenCL Introduction","text":"<p>Final</p> <p>This assignment description is now complete. There could still be minor updates, which will be highlighted. </p> <p>In this assignment, we explore OpenCL and Pynq. </p> <p>We start with configuring the computer (PC) and IDE to run OpenCL code. Instructions for Intel GPUs in Windows and Linux are provided. Instructions to run OpenCL on the Kria board are also provided.</p>"},{"location":"Assignment_3/1_OpenCL_Intro/#assignment-3","title":"Assignment 3","text":"<p>This assignment involves</p> <p>1) Accelerating the same computational problem as what you did in the previous 2 assignments - to be able to multiply two matrices A and B and to produce the result RES = A*B/256. This has to be done via</p> <ul> <li>OpenCL (GPU) on PC and </li> <li>Kria board (CPU) via Portable OpenCL (PoCL).\u00a0</li> </ul> <p>2) You must also report the time taken for multiplication in pure software (run without hardware acceleration / OpenCL) as well as with OpenCL.</p> <p>Note: Since the size of the problem you are dealing with is small, the acceleration you obtain won't be indicative. Also, operating system context switches make performance evaluation hard to do deterministically. It is also affected by caching, and generally, it is faster the second time you run it.</p> <p>If you have both onboard graphics (e.g. Intel) as well as a discrete GPU, it would be interesting to compare the performance of the two vs pure software.\u00a0This is not a requirement.</p> <p>3) Implement a Pynq-based acceleration on Kria board. Time measurement is optional, but recommended. The time reported should not include the time to program the bitstream.</p>"},{"location":"Assignment_3/1_OpenCL_Intro/#submission-info","title":"Submission Info","text":"<p>Assignment 3 (10 marks)</p> <p>Upload a .zip file containing the</p> <ul> <li>the .c host code</li> <li>the .cl kernel code if it is not embedded into the host code</li> <li>the .py file used with Pynq</li> <li>A text file containing the information printed on the console in each of the cases     1) OpenCL (GPU) on PC, with a comparison with plain C     2) OpenCL (CPU) on Kria, with a comparison with plain C     3) Pynq on Kria</li> </ul> <p>to Canvas by 11:59 PM, 1 Nov 2025.</p> <p>It should be as a .zip archive, with the filename \u00a0&lt;Team number&gt;_&lt;Team Member 1 Name&gt;_&lt;Team Member 1 Name&gt;_3.zip.</p> <p>Please\u00a0DO NOT\u00a0upload the whole project!</p> <p>You will also need to do a demonstration to a teaching assistant (arrangements will be made known in due course) - arrangements will be made known in due course.</p>"},{"location":"Assignment_3/1_OpenCL_Intro/#tips","title":"Tips","text":""},{"location":"Assignment_3/1_OpenCL_Intro/#multiple-platforms","title":"Multiple Platforms","text":"<p>If you have multiple GPUs (for example, integrated/onboard and discrete), the idea below could be useful. The idea could be extended for cases where there are multiple devices per platform.</p> <pre><code>cl_platform_id cpPlatform[2];\u00a0// If you have 2 platforms\n\n// Get IDs of both platforms\nerr = clGetPlatformIDs(2, cpPlatform, NULL);\n\n// Discrete GPU is likely cpPlatform[0] - you can find this info using clinfo. Change this to cpPlatform[1] to change to onboard graphics.\nerr = clGetDeviceIDs(cpPlatform[0], CL_DEVICE_TYPE_GPU, 1, &amp;device_id, NULL);\n</code></pre>"},{"location":"Assignment_3/1_OpenCL_Intro/#printing-kernel-program-build-log","title":"Printing Kernel Program Build Log","text":"<p>If you experience issues related to your device OpenCL code compilation failure, you should inspect the kernel build log.</p> <p>The most likely reason is that the .cl isn't accessible by the main program at runtime.</p> <p>Another reason is the use of <code>double</code> - OpenCL extension <code>cl_khr_fp64</code> - is not supported by Intel integrated GPUs. You can see the supported extensions via clinfo\u00a0- if you have only one GPU, see if\u00a0<code>clinfo | grep cl_khr_fp64</code>\u00a0gives some output.\u00a0Such issues can be debugged by inspecting the kernel program build log.</p>"},{"location":"Assignment_3/1_OpenCL_Intro/#setting-opencl-version","title":"Setting OpenCL Version","text":"<p>You may need to have <code>#define CL_TARGET_OPENCL_VERSION 120</code> at the beginning of the example code covered in the lecture, else you will get warnings such as <code>clCreateCommandQueue</code> being deprecated. <code>clCreateCommandQueue</code> usage is discouraged in versions &gt;=2.0, and the OpenCL version will default to the highest supported (likely 3.0 on Intel GPUs).\u00a0This is just a warning though, not an error.</p>"},{"location":"Assignment_3/2_OpenCL_Instructions/","title":"OpenCL Configuration","text":"<p>Follow the Spirit</p> <p>The instructions should be treated as a guideline rather than a very comprehensive manual. Figure out on your own how to solve issues, if any.</p> <p>It is generally easier to run OpenCL in a Linux distribution. Instructions for Windows are also provided, but expect some rough edges.</p> <p>Make sure your graphics drivers are up-to-date and supports OpenCL. The instructions assume an Intel GPU. For Nvidia and AMD GPUs, there are some differences in instructions, which you can figure out with a bit of Googling.</p> <p>Use path names without special characters or spaces for all paths.</p> <p>The template/data files are here.</p>"},{"location":"Assignment_3/2_OpenCL_Instructions/#installing-build-tools-and-opencl","title":"Installing Build Tools and OpenCL","text":"Ubuntu LinuxWindows <p>Refresh package list and update packages. <code>sudo apt update &amp;&amp; sudo apt upgrade</code>. You will be prompted for your Ubuntu password, and to confirm by pressing <code>y</code>.</p> <p>Install build tools, OpenCL libraries, and loader. <code>sudo apt install build-essential clinfo intel-opencl-icd ocl-icd-opencl-dev gdb</code>\u00a0(assuming Intel GPU. For Nvidia / AMD, appropriate drivers may need to be installed).</p> <p>Depending on the system configuration, other dependencies may also need to be installed.\u00a0<code>sudo apt -f install</code>\u00a0can usually help install these additional dependencies.</p> <p>Before building your program for the first time, it may be a good idea to refresh the linker cache via\u00a0<code>sudo ldconfig</code>.</p> <p>Run\u00a0<code>clinfo</code>\u00a0from the terminal and see if lists platforms and devices. If it lists platforms and devices, you are close! </p> <p>If it shows number of platforms as 0, you likely have a new (e.g, Raptor Lake U) processor. You can follow the guidelines on Intel website, reproduced below for convenience.</p> <p>Install the package for managing software repositories (likely already installed). <code>sudo apt-get install -y software-properties-common</code>.</p> <p>Add the intel-graphics PPA. <code>sudo add-apt-repository -y ppa:kobuk-team/intel-graphics</code>.</p> <p>Install Intel compute related packages. <code>sudo apt-get install -y libze-intel-gpu1 libze1 intel-metrics-discovery intel-gsc</code></p> <p>Try <code>clinfo</code> again and it should show platforms and devices.</p> <p>Install MSYS2: Install MSYS2. This provides a minimal Linux-like setup for Windows.</p> <p>Run MSYS2. It takes a few seconds to open.</p> <p>Install the compiler toolchain: Via the MSYS2 command line, run the following.</p> <p><code>pacman -Syu</code> to update the package manager.</p> <p>and then</p> <p><code>pacman -S mingw-w64-ucrt-x86_64-gcc</code> to install the GCC compiler</p> <p><code>pacman -S mingw-w64-ucrt-x86_64-gcd</code> to install the GNU debugger.</p> <p>By default, the toolchain is installed to C:\\msys64\\ucrt64. If you want to know the location, you can find out by typing <code>which g++</code>.</p> <p>Add the toolchain to Windows PATH: Win+S &gt; search for 'Environment Variables' &gt; Edit system environment variables &gt; Advanced Tab &gt; Environment Variables &gt; System Variables &gt; Path &gt; Edit &gt; New &gt;. Add the bin folder of your UCRT64 installation, e.g.: <code>C:\\msys64\\ucrt64\\bin and C:\\msys64\\ucrt64\\include</code>. Click OK to save changes.</p> <p>Verify Installation: Open Command Prompt (in start menu, type cmd) and run: g++ --version If installed correctly, it should display version information. Only new command windows can see the updated path, so if it was already open, close and reopen.</p> <p>Install OpenCL SDK: Download and Unzip Khronos OpenCL SDK (a newer release, if available, should be fine too).</p> <p>Unzip to <code>C:\\OpenCLSDK</code> such that <code>C:\\OpenCLSDK\\include</code> (contains CL/cl.h etc.) and <code>C:\\OpenCLSDK\\bin</code>(contains OpenCL.lib) exists. If you choose another path, modify command line build options and/or edit the VS Code config files accordingly.</p>"},{"location":"Assignment_3/2_OpenCL_Instructions/#configuring-visual-studio-code-ide","title":"Configuring Visual Studio Code IDE","text":"<p>Install VS Code IDE. This can be done in multiple different ways depending on the OS and package manager.</p> <p>Install the following extensions</p> <ul> <li>C/C++</li> <li>C/C++ Extension Pack</li> <li>CMake Tools (optional)</li> <li>OpenCL (optional, allows syntax highlighting of .cl files, has a built-in <code>clinfo</code> tool, etc.)</li> </ul> <p>You can use the folder/workspace from here. Include the complete folder, including the .vscode subfolder with the .json files that has various settings. Make appropriate changes to the paths in the .json files if necessary. The source file is slightly enhanced from the one explained in lecture notes. This file has enhanced debugging options, as well as time measurement-related functions.</p> <p>Build the project via Ctrl+Shift+B. This will create the executable <code>main.out</code> (Linux) or <code>main.exe</code> (Windows).</p> <p>Ensure that <code>kernel.cl</code> is in the same folder as the executable <code>main.out</code> or <code>main.exe</code></p> <p>Press F5 to run it with debugging.</p> <p>To run normally, go to the terminal of VS Code, ensure that you are in the folder with the <code>main.exe</code> / <code>main.out</code> (<code>cd</code> there if need be), and execute <code>.\\main.exe</code> or <code>./main.out</code>.</p> <p>Running in Windows is less stable, there is a higher likelihood of the runtime compilation of the kernel failing. Just run again if that happens.</p>"},{"location":"Assignment_3/2_OpenCL_Instructions/#compiling-and-running-from-command-line","title":"Compiling and Running from Command Line","text":"<p>This is optional, but can be faster than using an IDE. You can use the <code>main.cpp</code> from the archives above.</p> <p>Build the program via</p> LinuxWindows <p><code>g++ main.cpp -lOpenCL -o main.out</code></p> <p><code>g++ -g main.cpp -IC:/OpenCLSDK/include -LC:/OpenCLSDK/lib -lOpenCL -o main.exe</code></p> <p>after doing a <code>cd</code> to the folder/directory\u00a0with the source file. This will create the executable <code>main.out</code> or <code>main.exe</code>.</p> <p>Copy <code>kernel.cl</code> from the archives above to be in the same folder as the executable <code>main.out</code> or <code>main.exe</code>, as it is read and compiled at runtime. You can now run the executable by entering the command\u00a0<code>/main.out</code> or <code>.\\main.exe</code>. It should print the result 2-10 seconds later. If it works, you are good to go!</p> <p>If using <code>gcc</code> instead of <code>g++</code> and if you include <code>math.h</code>, <code>-lm</code> should be added to command line or VS Code <code>tasks.json</code>.</p>"},{"location":"Assignment_3/2_OpenCL_Instructions/#opencl-on-cpu-using-pocl","title":"OpenCL on CPU using PoCL","text":"<p>Portable Computing Language (PoCL) provides a portable OpenCL implementation that works with most CPUs and many GPUs. On CPUs, it can make use of all the cores/hardware threads. Installation in Windows is not straightforward, but possible.</p> <p>In Linux, you can install it via <code>sudo apt install pocl-opencl-icd</code>. </p> <p>Make slight adjustments to the code, by selecting the correct platform and device type.</p> <p>It works on the Kria board too if you boot Linux, and install PoCL. More instructions in this page.</p>"},{"location":"Assignment_3/3_Pynq_OpenCL_Kria/","title":"Pynq and OpenCL on Kria","text":"<p>Follow the Spirit</p> <p>The instructions should be treated as a rough guideline rather than a very comprehensive manual. Figure out on your own how to solve issues, if any.</p>"},{"location":"Assignment_3/3_Pynq_OpenCL_Kria/#booting-linux","title":"Booting Linux","text":"<p>For this part, we will boot Ubuntu Linux on Kria board. </p> <p> AMD/Xilinx does not provide a ready-to-use image for Kria board yet.</p> <p>A zipped SD card image is provided here - version 16_10_2025. The download password is mentioned in the Canvas announcements. Download and unzip the image (.img).</p> <p> The following changes were made to the image: </p> <ul> <li>Version 12_10_2025 : OpenCV downgraded to 4.10.0.84.</li> <li>Version 16_10_2025 : Size of image shrunk to less than 14 GB, which should fit into all 16 GB SD cards.</li> </ul> <p>It is the official Kria Ubuntu 22.04 image modified with the following:</p> <ul> <li>Pynq installed. It does not work out of the box and requires numpy to be downgraded to 1.26.4.  OpenCV should be downgraded to 4.10.0.84 for it to work with this version of numpy (not sure if it breaks any other package).</li> <li>PoCL installed.</li> <li>Example programmes for OpenCL and Pynq loaded.</li> </ul> <p>Some familiarity with Linux command line is handy from now on. Some useful commands are <code>ls</code>, <code>pwd</code>, <code>clear</code>, <code>nano</code> (command line text editor), <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>cat</code>, <code>mkdir</code>, <code>rmdir</code>. Read up more about these. Pressing tab will help with autocomplete and that can be very handing when operating from command line.</p> <p>Use the .img image and flash it to an SD card after plugging the SD card into your laptop\u2019s card reader or the provided card reader. The SD card should be at least 16 GB capacity. Note that 16 GB U1 cards do not work, which do not work with the upstream image either, and seem to have problems being detected by the board at a hardware level. </p> <p>Do not simply copy the .img over to the SD card; use an image writer application such as Raspberry Pi Imager (for CHOOSE OS, select the last option, i.e, 'use custom'; ignore the CHOOSE DEVICE option) or Win32 Disk Imager or balena Etcher or the ones bundled with Linux distributions (e.g., Disk Image Writer in Ubuntu - just right-click on the .img file in file explorer). The contents of the SD card will entirely be erased - make sure you choose the correct device/drive!.</p> <p>Insert the SD card into the micro SD card slot with the printed side facing up while the board is off. Turn the board on, and it will boot from SD Card to Ubuntu 22.04.</p> <p>There is a small chance it may not boot due to potential incompatibility between the board firmware and OS version. If this happens, you should update the firmware to the latest following the instructions - scroll towards the end of this page for updating firmware using the Boot Image Recovery Tool. This requires a direct Ethernet connection between the board and your laptop, and a static IP set for your laptop Ethernet interface.</p> <p>Every time before you power off, shut down the OS properly using <code>sudo shutdown -h now</code>. Wait until the LEDs next to the fan turns off before removing power.</p>"},{"location":"Assignment_3/3_Pynq_OpenCL_Kria/#interacting-with-linux-on-kria","title":"Interacting with Linux on Kria","text":"<p>Serial port involved minimal connections to the board, but is not very powerful / flexible. Ethernet has the advantage of not needing USB drive to copy programs/bitstream over, ability to use <code>apt</code> and <code>pip</code>, and provides a generally much better flexibility and experience than serial. However, setting up Ethernet based communication involves a bit more work.</p> <p>Another alternative to Ethernet or Serial: If you have an HDMI/DisplayPort monitor, keyboard and mouse: You can connect and operate like a normal computer.</p> <p>Some notes on how to use Serial and Ethernet are given below.</p> SerialEthernet <p>Use a terminal program and connect to the appropriate COM/tty/serial port as you did in assignment 1, baud rate of 115200. You will see the various boot messages.</p> <p>If using Windows on your laptop/PC, RealTerm can be used for this purpose, but it is not great to be used like a conventional high-level terminal, though it is great for low-level debugging. RealTerm shows all characters by default, including non-printable ones, which makes it look messy. In the display tab, change it to ANSI to make it operate like a normal terminal. Even then, it is not great for the purpose. It is suggested to use another terminal program such as the Serial funcionality of MobaXterm Home Editon.</p> <p>Eventually, it will throw up a login prompt. Username is ubuntu and password is the same as the one used for downloading the archive.</p> <p>If you had not connected to the serial port before the boot is complete, press enter, and it will show the login prompt.</p> <p> Use a wired (Ethernet) connection to a router or a laptop having an Ethernet interface / USB-Ethernet adapter. <p>To do anything via Ethernet, we need to have a mechanism whereby the Kria board Ethernet interface has a valid IP address. This is generally via DHCP, provided automatically by your router or laptop configured for internet connection sharing via Ethernet. The leasing of IP address is done only after the booting process is more or less complete. </p> <p>If connected to the router, there will be some status info in the router setup portal (very router dependent) that will list the IP address leases.</p> <p>In case of a connection directly to laptop, you will need to share your laptop internet connection via Ethernet. This is easy to accomplish in a few clicks in Windows or Linux GUI; ChatGPT will tell you how - rough idea illustrated in the screenshots below, but there could be differences depending on your specific laptop and OS version. The functionality is slightly finicky in Windows though, sometimes requiring you to unshare and share again.</p> LinuxWindows <p></p> <p></p> <p>You can find the IP address from your laptop via <code>arp -a</code> from both Windows (Start Menu &gt; cmd, or Start local terminal in MobaXterm) and Linux command line. In Windows, the IP address of the board will typically be 192.168.137.x, where x is between 2 and 254, corresponding to the Interface 192.168.137.1. If the interface looks like 169.x.x.x, it means internet connection sharing is not working. In Linux, the IP address given to the device is typically 10.42.0.x.</p> <p>The IP address can be also be found from Kria Linux commandline via a Serial connection, and running <code>hostname -I</code> or <code>ip addr show</code> or <code>ip a</code> or <code>ifconfig</code> - for the last 3 commands, look for the inet value corresponding to eth0.</p> <p>IP address can also be set statically depending on the use case. In this scenario, IP addresses of both the Kria board and the laptop Ethernet interface will need to be set statically. This provides stable connection settings - IP address will not change; but our ability to use anything that needs internet, such as <code>apt</code> and <code>pip</code> may be limited.</p> <p>You can use an SSH client such as MobaXterm on Windows or Muon SSH / bash terminal in Linux (<code>ssh -X ubuntu@&lt;kriaboard_ip_address&gt;</code>). You can even run GUI-based programs on Kria and have the display forwarded to your laptop (X forwarding).</p> <p>Alternatively, you can use the terminal within Jupyter Lab at &lt;kriaboard_ip_address&gt;:9090/lab via your browser- password to enter the web interface itself is xilinx. </p>"},{"location":"Assignment_3/3_Pynq_OpenCL_Kria/#opencl-on-kria","title":"OpenCL on Kria","text":"<p>Let us start with an OpenCL on CPU (Cortex A53). The main.cpp file is the same as the one we used with OpenCL on PC/Laptop. Just ensure that the correct platform id and device type are used in the .cpp file. Execute the following.</p> <p><code>cd /home/ubuntu/OpenCLExample</code> // change to the folder with OpenCL example.</p> <p><code>g++ main.cpp -lOpenCL -o main.out</code> // compile main.cpp</p> <p><code>./main.out</code> // run it.</p> <p>If you want to make minor edits to the .cpp file, you can do so using nano editor via the command <code>nano main.cpp</code>.</p> <p>Make sure that the line containing <code>#define XCLBIN</code> is commented out, as uncommenting it will cause the system to crash. It was an attempt to use OpenCL host code with the FPGA (PL) accelerator, which is not working, likely due to version-related issues.</p>"},{"location":"Assignment_3/3_Pynq_OpenCL_Kria/#pynq-on-kria","title":"Pynq on Kria","text":"<p>Pynq framework allows python code to interact with your custom coprocessor connected via AXI DMA (not AXI Stream FIFO).</p> <p>The example program adds 4 numbers, invoking the coprocessor and prints the sum, sum+1, sum+2, sum+3 (the coprocessor created using the example HLS code from Assignment 2).  </p> <p>Have a look at the .py code and understand the functionality. It is more or less the same as the C program used with AXI DMA, except that the bitstream is downloaded by the host python code, rather than before the host code is run (which was the case with Assignment 2). This also means a few seconds delay before the computation is started and results are printed.</p> <p>Pynq requires the .hwh file with the same name as the .bit file, and in the same folder. This is already done for the example in the PynqDMAExample folder.</p> <p><code>sudo -s</code> // the prompt will change to #. You are now in a root shell.</p> <p><code>source /etc/profile.d/pynq_venv.sh</code> // activate the virtual environment</p> <p><code>cd /home/ubuntu/PynqDMAExample/</code> // change to the directory containing the python script</p> <p><code>python3 PynqDMAExample.py</code> // run it</p> <p>To have a new .bit and .hwh, first have the .xsa ready. The .xsa can be unzipped using any tool that can deal with .zip (rename it to .zip if necessary). You will then find the .bit and the .hwh (The one we need is the top level .hwh, usually named design_1.hwh; not those named design_1_axi_smc_*.hwh) file. Rename the .hwh file to have the same as the .bit file, except for the extension.</p> <p>Update: Version 3.x of Pynq allows the unextracted .xsa file to be used directly</p> <p>If you have SSH /Jupyter lab access, you can copy these files via MobaXterm/Muon SSH/Jupyter lab UI conveniently.</p> <p>If not, you will need to do it via a USB drive, instructions given below. </p> Transferring files using a USB Drive <p>Copy the files to be transferred to a USB drive (not BitLocker-encrypted) from your laptop. Plug it into one of the USB ports.</p> <p>You can then copy the file (say, mybitstream.bit) from <code>/media/ubuntu/&lt;label&gt;</code> to your working directory (say, <code>/home/ubuntu/PynqDMAExample</code>) via the command</p> <p><code>cp /media/ubuntu/&lt;label&gt;/mybitstream.bit /home/ubuntu/PynqDMAExample</code>.</p> <p>Do the same for the <code>.hwh</code> file.</p> <p>You can find the <code>&lt;label&gt;</code> corresponding to your USB drive by pressing tab and looking at autocomplete options after typing <code>cp /media/ubuntu/</code>.</p> <p> If <code>/media/ubuntu/&lt;label&gt;</code> does not exist, it means your drive was not automounted. In this case, you need to mount it manually. Follow the steps below.</p> <p>First, find out the partition number of your USB drive. This can be done via the command <code>lsblk</code>. You will see something like</p> <p><code>sdb</code> <code>\u2514\u2500sdb1</code></p> <p>Here, <code>sdb</code> is the block device name and <code>sdb1</code> is the partition number. If it is different, make the changes are appropriate for the commands below. For now, we use a label/mountpoint <code>usbdrive</code>.</p> <p><code>sudo mkdir -p /media/ubuntu/usbdrive</code>  // to create a directory to mount the drive, if it does not exist.</p> <p><code>sudo mount /dev/sdb1 /media/ubuntu/usbdrive/</code>  // mount it. Will be read-only for the user ubuntu. This has to done with each unmounting or reboot. An alternative is an appropriate entry in /etc/fstab.</p> <p><code>cp /media/ubuntu/usbdrive/mybitstream.bit /home/ubuntu/PynqDMAExample</code>. // to copy the bitstream over to our working directory. </p> <p>Do the same for the <code>.hwh</code> file.</p> <p>Before removing the USB drive, it is a very good idea to unmount it via </p> <p><code>sudo umount /media/ubuntu/usbdrive</code>.</p> <p>If you made changes to your file directory on the Kria, in order to copy back to the USB drive, the drive should be mounted with write permissions for the user Ubuntu. It is easy to figure out how to do this with a bit of Googling.</p> <p>If you wish to make substantial changes to the .cpp file for OpenCL or .py file for Pynq, you can also edit on the laptop and copy it using one of the methods mentioned above.</p>"},{"location":"Installation/Installing_Vitis/","title":"Installing Vitis","text":""},{"location":"Installation/Installing_Vitis/#installing-vitis-20251","title":"Installing Vitis 2025.1","text":"<p>The complete development suite from AMD/Xilinx is also called Vitis, which includes Vivado - i.e., if you install Vitis, Vivado also gets installed. Vitis is used for the software part, Vivado is used for the hardware part.</p> <p>Installation in Linux is recommended, especially if you want to explore more. Some tools/features, such as AI Engine Development Flow, Petalinux, etc, are available only for Linux. The performance and stability are generally better under Linux, too. The basic requirements in can be met by a Windows installation.</p> <p>Vitis IDE has switched from Eclipse-based to Visual Studio Code-based. If you are using an older version of Vitis, it is better to stay with the Eclipse-based 'Vitis Classic' IDE as the VS based 'Vitis IDE' in these versions have rough edges (e.g.: driver generation for peripherals in PL). Newer (&gt;=2024.x) versions of Vitis based on VS Code are ok though, and are recommended.</p> <p>It is\u00a0not recommended\u00a0to install on macOS through a virtual machine. If you use a Mac, install Windows and/or Linux for a dual/triple boot.</p> <p>Some features of Vitis HLS require installing a free license, which has to be generated on the Xilinx/AMD website. Instructions for that are in the last section of this page. This is not needed for the first assignment, so you can install the license later, too.</p>"},{"location":"Installation/Installing_Vitis/#windows","title":"Windows","text":"<p>Below are the steps to be followed to install\u00a0Xilinx Vitis 2025.1. The instructions are for the web installer, which is recommended to avoid the hassle of downloading the full installer and uncompressing it.</p> <ul> <li> <p>You need an AMD account. If you don't, please create one.</p> </li> <li> <p>The AMD unified web installer is downloadable from the AMD website (Google for it).</p> </li> <li> <p>Run the downloaded file.</p> </li> <li> <p>Click Next, and enter your Xilinx account details. In the selection below, choose 'Download and Install Now'.</p> </li> <li> <p>Agree to all the license agreements on the next page.</p> </li> <li> <p>On the next page, select Vitis.</p> </li> <li> <p>On the next page, click Next.</p> </li> <li> <p>Do the selection as given in the screenshot below (taken in a slightly older version, but the selections are the same, though the UI may look slightly different in the recommended version, i.e., 2015.1). Must-haves are Vitis, Vivado, Vitis HLS, Install Devices for Kria SOMs and Starter Kits, Zynq UltraScale+ MPSoC, and Install Cable Drivers.</p> </li> </ul> <p></p> <ul> <li> <p>Artix-7 should be selected if you plan to play with other cheaper FPGAs in the future; else, uncheck it.</p> </li> <li> <p>If you plan to try Alveo on some cloud-based service (e.g., Nimbix cloud) in the future, select that too. It is unnecessary for CEG5203 and increases the install size substantially.</p> </li> <li> <p>Click Next and\u00a0select a suitable directory, Next, and Install. If you are prompted to allow installation of some hardware, firewall warnings about opening certain ports, etc, simply click allow without changing the default options. This may also happen during the first run of certain tools after installation. Make sure you allow or you will have a tough time fixing it later.</p> </li> <li> <p>When the installation is completed, click Finish to close the wizard.</p> </li> </ul>"},{"location":"Installation/Installing_Vitis/#linux","title":"Linux","text":"<p>Vitis/Vivado works very well in RHEL (best-supported)/Fedora/Ubuntu. The instructions below are for Ubuntu. The official instructions can be found here.</p> <ul> <li> <p>You need a Xilinx/AMD account. If you don't, please create one.</p> </li> <li> <p>Xilinx/AMD unified web installer for Linux is downloadable from the Xilinx/AMD website (Google for it).</p> </li> <li> <p>cd to download directory</p> </li> <li> <p>chmod +x .bin. No need for sudo unless you want to install in the default /opt directory. It is fine to install under /home/, and sudo is not needed. Please make sure you install to an Ext4 directory, not NTFS.</p> </li> <li> <p>Select the options as detailed in the Windows section above and complete the installation.</p> </li> <li> <p>A dialog box showing Tool installation completed will pop up, asking you to run the installLibs.sh under <code>&lt;install_dir&gt;/2025.1/Vitis/scripts</code> to install the necessary libraries, with sudo. Please oblige by changing to the above directory and running <code>sudo bash installLibs.sh</code>. Also do <code>sudo apt install build-essential</code> to install gcc and other tools that Vitis HLS depends on, but aren't installed by the installLibs.sh script (!).</p> </li> <li> <p>To install cable drivers to access the board, go to <code>&lt;install_dir&gt;/2025.1/Vitis/data/xicom/cable_drivers/lin64/install_script/install_drivers/</code> and run <code>./install_drivers</code>.</p> </li> <li> <p>If the desktop icon does not work or if you are ssh-ing into a remote Linux system with X forwarding, in the command line: <code>source\u00a0&lt;install_dir&gt;/2025.1/Vivado/settings64.sh</code>, followed by the command <code>vivado</code>.</p> </li> <li> <p>If starting from the GUI fails, run from the command line to identify the missing library and install it.</p> </li> <li> <p>Do <code>sudo adduser $USER dialout</code> if you want to be able to access local hardware without sudo.</p> </li> <li> <p>If you have trouble connecting to the board even after that, perhaps you should run <code>sudo ufw allow 3121/tcp</code>.</p> </li> </ul>"},{"location":"Installation/Installing_Vitis/#installing-vitis-hls-license","title":"Installing Vitis HLS License","text":"<p>The official instructions are here - https://docs.amd.com/r/en-US/ug1399-vitis-hls/Obtaining-a-Vitis-HLS-License.</p> <p>Go to\u00a0https://www.xilinx.com/getlicenseLinks.\u00a0Log in, fill up the license form.</p> <p>Under Certificate based license &gt; Vivado/Vitis HLS License &gt; Generate Node-Locked License &gt; System Information &gt; Host ID &gt; Enter the details.</p> <p>Host ID is your PC/Laptop hostname. Select the appropriate OS. Select Host ID Type as Ethernet MAC. Put in your MAC address as the Host ID value. You can find the MAC address using the <code>ipconfig /all</code> command in Windows (search for cmd in the start menu) and <code>ifconfig</code> command in Linux. Click Add and Next, Next.</p> <p>You can now download the license file . It will also be emailed to you.</p> <p>Now, in the Start menu, open Xilinx Design Tools &gt; Manage Licenses 2025.1. Now Get License &gt; Load License &gt; Copy License, and navigate to and select the .lic file. Restart all Xilinx programs (Vivado/Vitis, etc). Done!</p>"},{"location":"Project/Final_Project/","title":"Open-ended Project","text":"<p>The project is open-ended - you choose the application to accelerate as well as the exact stuff to do.</p> <p>Minimally, implement and compare the time taken when your application is</p> <ul> <li>run entirely on x86_64 CPU using plain C or PoCL vs</li> <li>hardware accelerated via OpenCL on integrated and/or discrete GPU.</li> </ul> <p>and</p> <ul> <li>run entirely on Kria (Zynq Ultrascale+) PS, i.e., Cortex A53 in plain C or PoCL vs</li> <li>accelerated using an FPGA/PL-based accelerator using HLS/HDL + AXI DMA / AXI Slave / AXI Master-based DMA-capable coprocessor. The host code can be plain C (Standalone/FreeRTOS/Linux) or Pynq.</li> </ul> <p>Comparison can be either based on profiling and/or based on a timer (hardware/software timer on FPGA, software timer on PC).</p>"},{"location":"Project/Final_Project/#sample-applications","title":"Sample Applications","text":"<p>Some sample applications are given below. These are just to provide a very rough idea of the stuff you can do.</p> <ul> <li>Easiest: Increasing or decreasing the brightness of images.</li> <li>Moderate: Edge detection using Sobel filters, Machine learning / classification (inference) using linear classifiers, etc.</li> <li>Harder: Object recognition in an image, deep learning based image processing, etc.</li> </ul> <p>As the focus of the module is not on algorithms themselves, but on how they can be accelerated, the complexity of the algorithm is not of great importance. Just that an algorithm that is too simple offers you little chance to try out optimizations.</p>"},{"location":"Project/Final_Project/#enhancements","title":"Enhancements","text":"<p>Try out various configurations and optimizations.</p> <p>HLS/HDL/OpenCL optimizations for FPGA such as unroll, pipeline, array partition, dataflow (applicable if you have multiple workgroups in the NDRange), Possible OpenCL optimizations for GPU such as vectorization and different workgroup sizes, Bit width optimizations (for both FPGA and GPU, but more applicable for FPGAs), etc. Present your results in a presentable manner - for example, as a proper image on PC irrespective of whether you process it on FPGA or PC. It is also possible to show the image on a monitor connected to FPGA directly using the TFT IP provided by Xilinx (if using standalone) or via the GUI of Linux!.</p> <p>For large data sizes, if using FIFO for testing (using DMA is strongly recommended), you will need to either 1) increase the FIFO transmit and/or receive buffer size as appropriate or 2) send/receive the data as multiple chunks, each not exceeding the respective buffer size.</p> <p>If you have large local arrays, you may need to increase the stack size. If you have large dynamic arrays, you will need to increase the heap size. This can be done by double-clicking the .ld file in the sources folder.</p> <p>Serial communication can be used for FPGA, with data sent via UART, but you can also consider exploring Ethernet-based communications. It is also possible to load the files from an SD card, though this requires either using FAT file system drivers (if using standalone) or running Linux.</p>"},{"location":"Project/Final_Project/#deliverables","title":"Deliverables","text":"<p>Make a short 10-minute presentation (7-8 minutes for presentation, 2-3 minutes for QnA) on your application, approaches, and results. Some of you will have to present in the Week 13 lecture, others will present at other time slots to the teaching assistants. The criterion for deciding who will have to present during the lecture will be announced later. A quick demo of your system during the presentation is appreciated, though not absolutely necessary. However, we reserve the right to require a quick demo after the presentation if we deem it necessary.</p> <p>No report is necessary, but the slides to be used for the presentation, all the codes (only source files - .c/.cpp/.h/.py you have created/edited) + .xdc files/files + data files + any PC-side visualization code should be uploaded to Canvas by 6 PM of Week 13 Tuesday.</p> <p>You should clearly demarcate and acknowledge the codes that are not written yourself, in the source code as well as in the presentation.</p>"}]}